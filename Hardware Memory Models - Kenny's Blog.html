<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.0.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/uploads/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/uploads/images/avatar_medium.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/uploads/images/avatar_small.ico">
  <link rel="mask-icon" href="/uploads/images/safari-pinned-tab.svg" color="#222">
  <link rel="manifest" href="/uploads/images/site.webmanifest">
  <meta name="google-site-verification" content="37N3k-QROe3gQuUhiCgmj6mBz0MRzeSNu79UBOwcyMs">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.2/css/all.min.css" integrity="sha256-CTSx/A06dm1B063156EVh15m6Y67pAjZZaQc89LLSrU=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"blog.kennycoder.io","root":"/","images":"/images","scheme":"Pisces","darkmode":true,"version":"8.18.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"width":240},"copycode":{"enable":true,"style":"mac"},"fold":{"enable":false,"height":500},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":true,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":true,"nav":{"disqus":{"text":"Load Disqus","order":-1}},"activeClass":"disqus"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"prism":false,"i18n":{"placeholder":"搜尋...","empty":"我們無法找到任何有關 ${query} 的搜索結果","hits_time":"${hits} 找到 ${time} 個結果","hits":"找到 ${hits} 個結果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="今天分享這篇文章的相關筆記，該文章的作者也是主要 Go 的 contributor 其中之一。這篇文章主要是介紹硬體記憶體模型有什麼類型以及其差別。作者這系列的文章總共有三篇，前面兩篇都算是鋪陳第三篇的 Go 的記憶體模型設計，所以透過前兩篇文章先講講硬體記憶體模型是什麼及區別，第二篇是講講其他語言的記憶體模型設計為何。">
<meta property="og:type" content="article">
<meta property="og:title" content="Hardware Memory Models - 筆記">
<meta property="og:url" content="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/index.html">
<meta property="og:site_name" content="Kenny&#39;s Blog">
<meta property="og:description" content="今天分享這篇文章的相關筆記，該文章的作者也是主要 Go 的 contributor 其中之一。這篇文章主要是介紹硬體記憶體模型有什麼類型以及其差別。作者這系列的文章總共有三篇，前面兩篇都算是鋪陳第三篇的 Go 的記憶體模型設計，所以透過前兩篇文章先講講硬體記憶體模型是什麼及區別，第二篇是講講其他語言的記憶體模型設計為何。">
<meta property="og:locale" content="zh_TW">
<meta property="og:image" content="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/p1.png">
<meta property="og:image" content="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/p2.png">
<meta property="og:image" content="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/p3.png">
<meta property="og:image" content="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/p4.png">
<meta property="og:image" content="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/p5.png">
<meta property="og:image" content="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/p6.png">
<meta property="og:image" content="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/p7.png">
<meta property="og:image" content="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/p8.png">
<meta property="og:image" content="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/p9.png">
<meta property="article:published_time" content="2022-07-18T02:39:18.000Z">
<meta property="article:modified_time" content="2023-11-05T15:31:17.474Z">
<meta property="article:author" content="KennyChen">
<meta property="article:tag" content="Notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/p1.png">


<link rel="canonical" href="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-TW","comments":true,"permalink":"https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/","path":"2022/07/18/Hardware-Memory-Models-筆記/","title":"Hardware Memory Models - 筆記"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Hardware Memory Models - 筆記 | Kenny's Blog</title>
  







<script data-ad-client="pub-6706352488491811" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> 


  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Kenny's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切換導航欄" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Kenny's Blog</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">這是Kenny's technology blog，歡迎交流_(:3」∠)_</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜尋" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首頁</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>關於</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>標籤<span class="badge">50</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分類<span class="badge">43</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>歸檔<span class="badge">118</span></a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>網站地圖</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜尋
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜尋..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目錄
        </li>
        <li class="sidebar-nav-overview">
          本站概要
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E4%BB%A5%E5%89%8D%E5%AF%AB-single-threaded-programs-%E7%9A%84%E6%99%82%E4%BB%A3"><span class="nav-number">1.</span> <span class="nav-text">在以前寫  single-threaded programs 的時代</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%95%B6-multi-processor-%E7%9A%84%E6%99%82%E5%80%99%E4%BE%86%E8%87%A8"><span class="nav-number">2.</span> <span class="nav-text">當 multi processor 的時候來臨</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memory-model-%E7%9A%84%E5%88%86%E9%A1%9E"><span class="nav-number">3.</span> <span class="nav-text">memory model 的分類</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sequential-Consistency"><span class="nav-number">4.</span> <span class="nav-text">Sequential Consistency</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x86-Total-Store-Order-x86-TSO"><span class="nav-number">5.</span> <span class="nav-text">x86 Total Store Order (x86-TSO)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-TSO-%E5%9D%8E%E5%9D%B7%E4%B9%8B%E8%B7%AF"><span class="nav-number">5.1.</span> <span class="nav-text">x86-TSO 坎坷之路</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM-POWER-Relaxed-Memory-Model"><span class="nav-number">6.</span> <span class="nav-text">ARM&#x2F;POWER Relaxed Memory Model</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Weak-Ordering-and-Data-Race-Free-Sequential-Consistency"><span class="nav-number">7.</span> <span class="nav-text">Weak Ordering and Data-Race-Free Sequential Consistency</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B8%BD%E7%B5%90"><span class="nav-number">8.</span> <span class="nav-text">總結</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="KennyChen"
      src="/uploads/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">KennyChen</p>
  <div class="site-description" itemprop="description">分享生活、工作雜談、技術文章^^</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">118</span>
          <span class="site-state-item-name">文章</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">分類</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">50</span>
        <span class="site-state-item-name">標籤</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/KennyChenFight" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;KennyChenFight" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/cdn-cgi/l/email-protection#f69d9398988f959e9398cec3c7c4c4ceb6919b979f9ad895999b" title="E-Mail → mailto:kennychen851228@gmail.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.facebook.com/kennychenfight" title="FB Page → https:&#x2F;&#x2F;www.facebook.com&#x2F;kennychenfight" rel="noopener me" target="_blank"><i class="fab fa-facebook fa-fw"></i>FB Page</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.linkedin.com/in/kennycoder" title="Linkedin → https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;kennycoder" rel="noopener me" target="_blank"><i class="fab fa-linkedin fa-fw"></i>Linkedin</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.youtube.com/channel/UC8X8DHBesfFRpkFGX4VTJTw" title="YouTube → https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UC8X8DHBesfFRpkFGX4VTJTw" rel="noopener me" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml" rel="noopener me"><i class="fas fa-rss fa-fw"></i>RSS</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-TW">
    <link itemprop="mainEntityOfPage" href="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/images/avatar.jpg">
      <meta itemprop="name" content="KennyChen">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kenny's Blog">
      <meta itemprop="description" content="分享生活、工作雜談、技術文章^^">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Hardware Memory Models - 筆記 | Kenny's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Hardware Memory Models - 筆記
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">發表於</span>

      <time title="創建時間：2022-07-18 10:39:18" itemprop="dateCreated datePublished" datetime="2022-07-18T10:39:18+08:00">2022-07-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新於</span>
      <time title="修改時間：2023-11-05 23:31:17" itemprop="dateModified" datetime="2023-11-05T23:31:17+08:00">2023-11-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分類於</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Notes/" itemprop="url" rel="index"><span itemprop="name">Notes</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Disqus：</span>
    
    <a title="disqus" href="/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/#disqus_thread" itemprop="discussionUrl">
      <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2022/07/18/Hardware-Memory-Models-筆記/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 多媒體 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-6706352488491811"
     data-ad-slot="4777476933"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="文章字數">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">文章字數：</span>
      <span>9.9k</span>
    </span>
    <span class="post-meta-item" title="所需閱讀時間">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">所需閱讀時間 &asymp;</span>
      <span>18 分鐘</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
<p>今天分享這篇<a target="_blank" rel="noopener" href="https://research.swtch.com/hwmm">文章</a>的相關筆記，該文章的作者也是主要 Go 的 contributor 其中之一。這篇文章主要是介紹硬體記憶體模型有什麼類型以及其差別。作者這系列的文章總共有三篇，前面兩篇都算是鋪陳第三篇的 Go 的記憶體模型設計，所以透過前兩篇文章先講講硬體記憶體模型是什麼及區別，第二篇是講講其他語言的記憶體模型設計為何。</p>
<span id="more"></span>
<h2 id="在以前寫-single-threaded-programs-的時代">在以前寫  single-threaded programs 的時代</h2>
<p>在以前的年代，大家都還在只能寫 single-threaded programs 的時候，當下一代的硬體或是編譯器升級後，要怎麼判斷程式有沒有性能上的提升呢？</p>
<blockquote>
<p>如果 programmer 無法判斷硬體升級前後的程式執行結果有什麼差別，那麼這個硬體的升級就是有效的。</p>
</blockquote>
<p>我認為講白的就是，硬體升級後，如果速度上有提升，且執行結果沒有差別，就斷定硬體的升級是有效的。</p>
<h2 id="當-multi-processor-的時候來臨">當 multi processor 的時候來臨</h2>
<p>隨著時代的演進，<strong>multi-processor</strong> 來臨後，我們開始可以寫 <strong>multi-thread</strong> 程式，這時許多在 single-threaded programs 看不到的問題就會產生了，無法再用以前的方式看待程式性能是否有提升，因為如果沒解決 multi-thread 會出現的問題，你的執行結果可能就會跟以前不同！</p>
<p>來看個例子：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1             // Thread 2</span></span><br><span class="line">x = <span class="number">1</span> ;                 <span class="keyword">while</span> (done == <span class="number">0</span> ) { <span class="comment">/* loop */</span> }</span><br><span class="line">done = <span class="number">1</span> ;              print(x);</span><br></pre></td></tr></tbody></table></figure>
<p>問題：Thread 2 有可能 print 0 嗎？</p>
<ol>
<li>根據硬體及編譯器才能決定是否會出現這種結果</li>
<li>如果是 <a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-tw/X86"><strong>x86</strong></a> 且採用逐行轉成 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><strong>assembly language</strong></a>，會 always print 1</li>
<li> 如果是 <a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-tw/ARM%E6%9E%B6%E6%A7%8B"><strong>ARM</strong></a> or <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IBM_POWER%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8"><strong>POWER</strong></a> 且一樣採用逐行轉成 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80"><strong>assembly language</strong></a> 會有機會 print 0</li>
<li> 但是不管底層硬體是什麼，編譯器的優化策略也會導致有 print 0 或是進行無限 loop 的可能</li>
</ol>
<p>之所以會有多種運行結果產生，是因為對 memory 裡面的資料存取或更改的策略不同導致的結果，也就所謂的可見性及一致性，因為不同的硬體架構下，處理器對於 memory 的策略會不同，而這種策略，我們就叫做 <strong>memory model</strong>。</p>
<h2 id="memory-model-的分類">memory model 的分類</h2>
<p>在最一開始 memory model 來自於硬體對於操作記憶體的概念，這時候還沒有所謂的編譯器的參與。而之後幾年開始有了編譯器之後，那 memory model 就可以分為硬體或軟體的 memory model</p>
<ul>
<li><strong>hardware memory model</strong>
<ul>
<li> 可以理解硬體 (其實也就是處理器) 與 memory 操作的協議，說明什麼情況的可見性及一致性怎麼發生</li>
</ul>
</li>
<li><strong> software memory model</strong>
<ul>
<li> 由於在程式語言及編譯器的出現後，編譯器會有所謂的優化策略，可以將每一行程式碼進行重排來獲得更好的執行效率，這時候對於 memory 的存取就會有其可見性及一致性需要規範，這些機制來告訴 programmer 要怎麼寫 code</li>
</ul>
</li>
</ul>
<p>而 memory model 又根據一致性區分出強一致性與弱一致性的類型，所以這篇文章主要要著重於 <strong>hardware memory model</strong> 強與弱的類型介紹。</p>
<h2 id="Sequential-Consistency">Sequential Consistency</h2>
<p>Sequential Consistency 來自於 Leslie Lamport 1979 年的論文<a target="_blank" rel="noopener" href="https://www.microsoft.com/en-us/research/publication/make-multiprocessor-computer-correctly-executes-multiprocess-programs/">《How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs》</a>：</p>
<blockquote>
<p>The customary approach to designing and proving the correctness of multiprocess algorithms for such a computer assumes that the following condition is satisfied: the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program. A multiprocessor satisfying this condition will be called sequentially consistent.</p>
</blockquote>
<p>直白來說就是：所有處理器的操作都是按某種順序執行的，每個處理器的操作都是按程式指定的順序出現的，滿足這一條件的多處理器系統將被稱為順序一致 (Sequential Consistency) 的。</p>
<p>而這樣的順序一致的方式也是符合 progammer 的寫程式的直覺，因為就是程式碼按照我們寫的一行一行依序去執行，不會有重排的問題發生。而在 multi-thread 上，sequential consistency 保證不同 thread 的執行方式只是以某種順序來進行交替 (interleaving)，而不是以其他方式排列。</p>
<p>來看個例子：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Litmus Test: Message Passing</span><br><span class="line">Can this program see r1 = <span class="number">1</span> , r2 = <span class="number">0</span> ?</span><br><span class="line"><span class="comment">// Thread 1            // Thread 2</span></span><br><span class="line">x = <span class="number">1</span>                  r1 = y</span><br><span class="line">y = <span class="number">1</span>                  r2 = x</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Litmus Test 代表測試只有兩種答案，這個運行結果是可能還是不可能發生。</li>
<li>這個例子中，假設沒有編譯器的優化策略干擾，每一個 thread 的指令就是處理器要執行的指令。</li>
</ul>
<p>如果是 <strong>Sequential Consistency</strong> 會出現六種可能的交替執行結果：</p>
<p><img data-src="p1.png" alt="p1"></p>
<p>根據這樣的結果得知：<code>r1 = 1 , r2 = 0</code> 是不可能發生的。</p>
<p>Sequential Consistency 的實現方式可以想像是所有處理器共享一個 shared memory，它可以一次處理一個 thread 的 read or write，不涉及 cache，因此每個處理器需要讀取或寫入 memory 時，該請求都會到 shared memory，一次使用一次的 shared memory 對所有 memory 存取的執行添加了順序，所以導致了 Sequential Consistency，看圖會更理解：</p>
<p><img data-src="p2.png" alt="p2"></p>
<p>但是夢想是美好的，現實是殘忍的，要實現這樣 Sequential Consistency 並不容易，而且最大問題是同一時間只有 single thread 可以存取 memory，這樣的方式削弱 multi-processor 的幫助。因此現今的硬體都不是走 Sequential Consistency 來提升性能。</p>
<p>總結 Sequential Consistency：</p>
<ul>
<li>程式的執行順序按照程式碼順序</li>
<li>程式碼中對於記憶體的訪問不會被亂序</li>
</ul>
<h2 id="x86-Total-Store-Order-x86-TSO">x86 Total Store Order (x86-TSO)</h2>
<p>x86 的 memory model 如下圖：</p>
<p><img data-src="p3.png" alt="p3"></p>
<ol>
<li>所有處理器仍然共用 shared memory</li>
<li> 每個處理器對 memory 的 write 放到 local write queue 中後，繼續執行新指令，而 queue 中的 write 操作也會更新到 shared memory</li>
<li> 一個處理器的 memory 讀取順序會先讀 local write queue，但是看不到其他處理器的 local write queue，這樣變成當前處理器會比其他處理器會先看到自己的 write 操作。</li>
<li>而 Total Store Order 來自於：所有處理器都保證寫入 (等同於 store 的概念) 到 shared memory 的 total order。</li>
<li>當一個 write 操作到達 shared memory 時，任何處理器上的未來 read 操作都將看到它並使用該值，除非它被之後 write 操作覆蓋，其他處理器才會採納 new value。</li>
<li>write queue 是 first-in-first-out 策略，所以處理器執行的順序就等於 shared memory 存 write 的順序</li>
</ol>
<p>那麼再來看前面的例子：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Litmus Test: Message Passing</span><br><span class="line">Can this program see r1 = <span class="number">1</span> , r2 = <span class="number">0</span> ?</span><br><span class="line"><span class="comment">// Thread 1            // Thread 2</span></span><br><span class="line">x = <span class="number">1</span>                  r1 = y</span><br><span class="line">y = <span class="number">1</span>                  r2 = x</span><br><span class="line">On sequentially consistent hardware: no.</span><br><span class="line">On x86 (or other TSO): no.</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>因為 write queue 保證 thread 1 在 y 之前就將 x 寫入 memory 了，而 thread 2 是先讀 y 再讀 x，是不可能再看不到新的ｘ之前就能看到新的 y，說起來饒口就是了。</p>
<blockquote>
<p>這些順序就是 Total Store Order 的保證：thread 1 在寫入 y 之前先寫入 x，因此 thread 2 在看到 x 的寫入之前不可能看到 y 的寫入。</p>
</blockquote>
</li>
</ul>
<p>那麼 Sequential Consistency 與 Total Store Order 的差別在哪呢？來看個例子：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Litmus Test: Write <span class="title function_">Queue</span> <span class="params">(also called Store Buffer)</span></span><br><span class="line">Can this program see r1 =  <span class="number">0</span> , r2 =  <span class="number">0</span> ?</span><br><span class="line"><span class="comment">// Thread 1            // Thread 2</span></span><br><span class="line">x =  <span class="number">1</span>                 y =  <span class="number">1</span></span><br><span class="line">r1 = y                 r2 = x</span><br><span class="line">On sequentially consistent hardware: no.</span><br><span class="line">On x86 ( or other TSO): yes!</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>
<p>在 sequential consistency 的情況， <code>x=1</code> 或 <code>y=1</code> 必然先發生，且另外一個 thread 讀取的時候就必定能夠觀察到這賦值，所以 <code>r1 = 0</code> and <code>r2 = 0</code> 不可能發生</p>
</li>
<li>
<p>但是在 TSO 的情況下，thread 1 和 thread 2 可能會將它們的 write 操作在 queue 中排隊，因為如果還沒進入到 shared memory 之前，其他 thread 就開始讀取的話，這樣兩個 read 操作都會看到 0</p>
</li>
<li>
<p>這種需要用到兩個同步變數常常出現在知名的同步算法中，例如：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Dekker's_algorithm">Dekker’s algorithm</a> or <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Peterson's_algorithm">Peterson’s algorithm</a>。</p>
<ol>
<li>為了滿足上面這種演算法並提供更強的 memory order，非 sequential consistency 通常會提供稱為 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-tw/%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><strong>memory barrier</strong></a> 的指令用來控制順序：</li>
</ol>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread 1       // Thread 2</span></span><br><span class="line">x = <span class="number">1</span>             y = <span class="number">1</span></span><br><span class="line">barrier           barrier</span><br><span class="line">r1 = y            r2 = x</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>透過 memory barrier 的幫助， 保證在關鍵時刻可以強制順序一致的方法，至於 memory barrier 具體細節會依據不同處理器的架構而不同。</li>
</ul>
</li>
</ol>
<p>再來看個例子：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Litmus Test: Independent Reads of Independent <span class="title function_">Writes</span> <span class="params">(IRIW)</span></span><br><span class="line">Can this program see r1 =  <span class="number">1</span> , r2 =  <span class="number">0</span> , r3 =  <span class="number">1</span> , r4 =  <span class="number">0</span> ?</span><br><span class="line">(Can Threads <span class="number">3</span>  and  <span class="number">4</span> see x and y change in different orders?)</span><br><span class="line"><span class="comment">// Thread 1     // Thread 2     // Thread 3     // Thread 4</span></span><br><span class="line">x =  <span class="number">1</span>          y =  <span class="number">1</span>          r1 = x          r3 = y</span><br><span class="line">                                r2 = y          r4 = x</span><br><span class="line">On sequentially consistent hardware: no.</span><br><span class="line">On x86 ( or other TSO): no.</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>如果 thread 3 在 y 之前就看到 x 的變化，那麼 thread 4 可以在 x 之前就先看到 y 的變化嗎？
<ol>
<li>對於 sequentially consistent and x86 (or other TSO) 都是不可能看到的，因為對於 shared memory 所有的寫入都有一個 total order，所有處理器都會認同這個 order，因此當 thread 3 確定了 x 先於 y 的 order，thread 4 就不可能能夠相反的看到 y 先於 x 的 order，每個處理器只有在到達 shared memory 前可以先知道自己的寫入而已。</li>
</ol>
</li>
</ol>
<h3 id="x86-TSO-坎坷之路">x86-TSO 坎坷之路</h3>
<p>這邊主要作者提到 x86-TSO 的發展不順的歷史，例如第一批的 x86 處理器的手冊幾乎沒有提到硬體提供的 memory model 是怎樣操作的，因此常常開發人員被 local write queue 的不期望的行為所困擾，並且當時 intel 架構人員不願意為未來的處理器做出任何保證，其手冊中存在的少量文本幾乎沒有任何保證，使得很難針對它們進行 coding。</p>
<p>在 2007 年 8 月出版的 <a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf">Intel 64 Architecture Memory Ordering White Paper</a>，終於提出了：" 提供軟體工程師對不同順序的 memory 存取指令可能產生結果的各種情況 “。而 AMD 在 [AMD64 Architecture Programmer’s Manual revision 3.14](<a target="_blank" rel="noopener" href="https://courses.cs.washington.edu/courses/cse351/12wi/supp-docs/AMD">https://courses.cs.washington.edu/courses/cse351/12wi/supp-docs/AMD</a> Vol 1.pdf) 中發表了類似的描述。</p>
<p>然而這些描述反而是提出了 TLO (Total Lock Order) + CC (Causal Consistency) 模型，提供一致性比 TSO 還弱：</p>
<blockquote>
<p>intel 架構師表示，TLO+CC <a target="_blank" rel="noopener" href="http://web.archive.org/web/20080512021617/http://blogs.sun.com/dave/entry/java_memory_model_concerns_on">“像要求的那樣強大，但並不足夠強大。”</a></p>
</blockquote>
<p>並且在 Litmus Test: Independent Reads of Independent Writes (IRIW) 居然會產生這樣的可能，且 memory barrier 不夠厲害，不足以可以達到 sequential consistent 的效果。</p>
<p>此外，x86 TLO+CC 模型也無法達到以下的實驗：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Litmus Test: n6 (Paul Loewenstein)</span><br><span class="line">Can this program end  with r1 = <span class="number">1</span> , r2 = <span class="number">0</span> , x = <span class="number">1</span> ?</span><br><span class="line"><span class="comment">// Thread 1     // Thread 2</span></span><br><span class="line">x = <span class="number">1</span>           y = <span class="number">1</span></span><br><span class="line">r1 = x          x = <span class="number">2</span></span><br><span class="line">r2 = y</span><br><span class="line">On sequentially consistent hardware: no .</span><br><span class="line">On x86 TLO+CC model ( <span class="number">2007</span> ): no .</span><br><span class="line">On actual x86 hardware: yes!</span><br><span class="line">On x86 TSO model: yes! (Example from x86-TSO paper.)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>說實在這個實驗我不是看很懂，為什麼前兩個 model 會是 no，QQ 看來只能再問問公司的大神了</li>
</ul>
<p>在 2008 年 intel 和 AMD 修訂規範並保證了 IRIW case 的 “不”，並加強了 memory barrier，但仍允許不可預期的行為：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Litmus Test: n5</span><br><span class="line">Can this program end  with r1 = <span class="number">2</span> , r2 = <span class="number">1</span> ?</span><br><span class="line"><span class="comment">// Thread 1     // Thread 2</span></span><br><span class="line">x = <span class="number">1</span>           x = <span class="number">2</span></span><br><span class="line">r1 = x          r2 = x</span><br><span class="line">On sequentially consistent hardware: no .</span><br><span class="line">On x86 specification ( <span class="number">2008</span> ): yes!</span><br><span class="line">On actual x86 hardware: no .</span><br><span class="line">On x86 TSO model: no . (Example from x86-TSO paper.)</span><br></pre></td></tr></tbody></table></figure>
<p>為了解決上面問題，Owens <em>et</em> <em>al</em>. 在<a target="_blank" rel="noopener" href="https://research.swtch.com/sparcv8.pdf">早期 SPARCv8 TSO 模型</a>的基礎上提出了 <a target="_blank" rel="noopener" href="https://www.cl.cam.ac.uk/~pes20/weakmemory/x86tso-paper.tphols.pdf">x86-TSO 模型提案</a>。並聲稱：</p>
<blockquote>
<p>“To the best of our knowledge, x86-TSO is sound, is strong enough to program above, and is broadly in line with the vendors’ intentions.”</p>
<p>A few months later Intel and AMD released new manuals broadly adopting this model.</p>
</blockquote>
<p>所以可以知道 intel 和 AMD 花了不少時間：</p>
<blockquote>
<p>how to write a memory model that left room for future processor optimizations while still making useful guarantees for compiler writers and assembly-language programmers. “As strong as required but no stronger” is a difficult balancing act.</p>
</blockquote>
<p>說實在我覺得有些英文句子很難翻譯 ==，就這樣吧… 總而言之花了不少時間來達到真正的 TSO model。</p>
<h2 id="ARM-POWER-Relaxed-Memory-Model">ARM/POWER Relaxed Memory Model</h2>
<p>前面的 Sequential Consistency 跟 TSO 都是屬於偏強一致性的，那麼就來講講比較弱一致性的 memory model，主要是用在 ARM/POWER 架構上的處理器上。</p>
<p><img data-src="p4.png" alt="p4"></p>
<ul>
<li>
<p>每個處理器都只對自己的 complete copy of memory 進行讀取及寫入，而寫入的結果也會傳播到其他處理器的 memory copy 上，由於寫入的傳播不固定所以允許重新排序，因此這邊沒有所謂的 total store order</p>
</li>
<li>
<p>每個處理其也被允許可以 postpone a read until it needs the result，延遲讀取的意思，當前 read 的 code 可以延遲到之後的 write 之後，所以上面的 litmus test 都是有可能發生的</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Litmus Test: Message Passing</span><br><span class="line">Can this program see r1 = <span class="number">1</span> , r2 = <span class="number">0</span> ?</span><br><span class="line"><span class="comment">// Thread 1            // Thread 2</span></span><br><span class="line">x = <span class="number">1</span>                  r1 = y</span><br><span class="line">y = <span class="number">1</span>                  r2 = x</span><br><span class="line">On sequentially consistent hardware: no.</span><br><span class="line">On x86 (or other TSO): no.</span><br><span class="line">On ARM/POWER: yes!</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>想像 thread 1 and thread 2 有自己獨立的 memory copy，write 可以以任何順序在 memory 之間傳播，所以 thread 1 的 x 的更新傳播有可能是在 y 的更新傳播之後，並且 thread 2 在這兩個更新傳播進行讀取就會看到 <code>r1 = 1</code> and <code>r2 = 0</code>    的結果</li>
</ul>
</li>
<li>
<p>再來看一些例子：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Litmus Test: Store Buffering</span><br><span class="line">Can this program see r1 = <span class="number">0</span> , r2 = <span class="number">0</span> ?</span><br><span class="line"><span class="comment">// Thread 1           // Thread 2</span></span><br><span class="line">x = <span class="number">1</span>                 y = <span class="number">1</span></span><br><span class="line">r1 = y                r2 = x</span><br><span class="line">On sequentially consistent hardware: no.</span><br><span class="line">On x86 (or other TSO): yes!</span><br><span class="line">On ARM/POWER: yes!</span><br></pre></td></tr></tbody></table></figure>
<p>這種情況會與 TSO 的行為一致。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Litmus Test: Independent Reads of Independent <span class="title function_">Writes</span> <span class="params">(IRIW)</span></span><br><span class="line">Can this program see r1 =  <span class="number">1</span> , r2 =  <span class="number">0</span> , r3 =  <span class="number">1</span> , r4 =  <span class="number">0</span> ?</span><br><span class="line">(Can Threads <span class="number">3</span>  and  <span class="number">4</span> see x and y change in different orders?)</span><br><span class="line"><span class="comment">// Thread 1     // Thread 2     // Thread 3     // Thread 4</span></span><br><span class="line">x =  <span class="number">1</span>           y =  <span class="number">1</span>         r1 = x          r3 = y</span><br><span class="line">                                r2 = y          r4 = x</span><br><span class="line">On sequentially consistent hardware: no.</span><br><span class="line">On x86 ( or other TSO): no.</span><br><span class="line">On ARM/POWER: yes!</span><br></pre></td></tr></tbody></table></figure>
<p>這種情況只有 ARM/POWER 才會發生。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Litmus Test: Load Buffering</span><br><span class="line">Can this program see r1 = <span class="number">1</span> , r2 = <span class="number">1</span> ?</span><br><span class="line">(Can each thread <span class="string">'s read happen after the other thread'</span> s write ?)</span><br><span class="line"><span class="comment">// Thread 1     // Thread 2</span></span><br><span class="line">r1 = x          r2 = y</span><br><span class="line">y = <span class="number">1</span>           x = <span class="number">1</span></span><br><span class="line">On sequentially consistent hardware: no .</span><br><span class="line">On x86 ( or other TSO): no .</span><br><span class="line">On ARM/ POWER : yes!</span><br></pre></td></tr></tbody></table></figure>
<p>剛才說過 read 可以延遲後做，所以也會導致這種情況發生。</p>
</li>
</ul>
<p>而 ARM 和 POWER 也有 memory barrier，可以在上面的例子中插入這些 memory barrier，來達到強制順序一致的行為，但是有什麼情況是都不會發生的呢：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Litmus Test: Coherence</span><br><span class="line">Can this program see r1 =  <span class="number">1</span> , r2 =  <span class="number">2</span> , r3 =  <span class="number">2</span> , r4 =  <span class="number">1</span> ?</span><br><span class="line">(Can Thread <span class="number">3</span> see x =  <span class="number">1</span> before x =  <span class="number">2</span> <span class="keyword">while</span> Thread <span class="number">4</span> sees the reverse?)</span><br><span class="line"><span class="comment">// Thread 1     // Thread 2     // Thread 3     // Thread 4</span></span><br><span class="line">x =  <span class="number">1</span>           x =  <span class="number">2</span>         r1 = x          r3 = x</span><br><span class="line">                                r2 = x          r4 = x</span><br><span class="line">On sequentially consistent hardware: no.</span><br><span class="line">On x86 ( or other TSO): no.</span><br><span class="line">On ARM/POWER: no.</span><br></pre></td></tr></tbody></table></figure>
<p>之所以會這樣是因為：threads in the system must agree about a total order for the writes to a single memory location.</p>
<p>也就是說 threads 對於單個變數的 memory location 改變順序要同意一致，所以 thread 3 看到了 r1 = 1, r2 = 2，看到了 x 變化順序是 1 =&gt; 2 所以 Thread 4 也必須看到同樣的變化順序才可以，這樣的性質叫做 <strong>coherence</strong> ，如果沒有這個性質，處理器有可能不同意 memory 儲存的最終結果或是 report a memory location flip-flopping from one value to another and back to the first.</p>
<p>這邊我還是有點難以理解根據傳播的不同，為何不會發生上面的情況，還是就是強制有 coherence 的特性呢？QQ</p>
<h2 id="Weak-Ordering-and-Data-Race-Free-Sequential-Consistency">Weak Ordering and Data-Race-Free Sequential Consistency</h2>
<p>在硬體的 memory model 下產生了各種各樣的可能，因此這邊就有人提出所謂的同步模型：</p>
<p>Sarita Adve 和 Mark Hill 在 1990 年的論文 <a target="_blank" rel="noopener" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.5567">“Weak Ordering – A New Definition”</a> 中提出 “weak ordering” 定義為如下：</p>
<blockquote>
<p>Let a synchronization model be a set of constraints on memory accesses that specify how and when synchronization needs to be done.</p>
<p>意思是說，同步模型是對 memory access 的一種約束，這些約束指定了何時以及如何進行同步</p>
</blockquote>
<p>其中一種同步模型叫做：<strong>data-race-free(DRF)</strong></p>
<p>假設硬體擁有 memory 同步操作，這些同步操作可以將 memory 的 read and write 進行重新排序，有點像是說可用來做重新排序的 memory barrier</p>
<p>來看個例子：</p>
<p><img data-src="p5.png" alt="p5"></p>
<p>兩個 thread 彼此之間會有 race condition 是對於 x 的 write 操作，thread 2 與 thread 1 的寫入和讀取競爭，而如果 thread 2 是讀取 x 則代表 thread 1 的寫與 thread 2 讀之間只有一個競爭。</p>
<p>為了避免 race condition，加入了同步操作：</p>
<p><img data-src="p6.png" alt="p6"></p>
<p>強制 thread 2 W (x) 在 thread 1 R (x) 之後，就不會有 race condition</p>
<p>如果是 thread 2 只是 R (x)，則改成這樣：</p>
<p><img data-src="p7.png" alt="p7"></p>
<p>同步操作也可以利用中間的 thread 來達到：</p>
<p><img data-src="p8.png" alt="p8"></p>
<p>如果誤用同步操作還是會造成 race condition：</p>
<p><img data-src="p9.png" alt="p9"></p>
<p>thread 1 與 thread 3 的 W (x) 沒有經過同步，所以不是 data-race-free</p>
<p>這種 weak ordering 的性質可以想成是硬體和軟體之間的協議方式，也就是說我們如果軟體可以解決 race condition，那麼硬體就相當於是跑 sequential consistency 的樣子。</p>
<p>因此之後的硬體會實作這些同步操作來讓我們這些軟體工程師來使用，就是這樣的道理！這種觀點也叫做：<strong>DRF-SC</strong>(data-race-ree sequential consistency)</p>
<p>作者之所以要提這個觀念，是因為下篇文章就是講現在的程式語言的 memory model 的原理是怎麼做的，其實這就回歸我們前面說的概念那就是 software memory model。只要硬體能夠滿足軟體同步操作的實作，那麼只要軟體工程師的 software memory model 做得好，或者應該說讓編譯器的優化策略照著你想要的走，那麼就不會有 race condition。</p>
<h2 id="總結">總結</h2>
<p>這篇文章說實在我覺得有點抽象不是很好理解，我自己也是看了不少篇文章來理解，我也不確定我理解的對不對，對我來說 memory model 就是一種協議的感覺，並且根據硬體跟軟體拆成兩種性質的 memory model，一個是硬體與 memory 寫入 / 存取，一個是編譯器對於 memory 的優化策略之類的，可能會重組我們寫好的程式碼，來提升性能，而程式語言本身也會提供給我們一些同步操作來避免 race condition，這些同步操作會迫使編譯器編譯成機器碼的時候去做相對應的轉換，相對的硬體也必須支援這樣的操作才行。</p>
<p>而 memory model 又區分為強 / 弱一致性，而會讓硬體處理上產生各種不同的運行結果。</p>
<p>以上是我的理解，歡迎指教。</p>

    </div>

    
    
    

    <footer class="post-footer"><div>
  最後，如果你覺得這篇文章對你有幫助，可以透過下方的連結給我點支持來繼續寫作的動力，謝謝。
  <script type="text/javascript" src="https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js" data-name="bmc-button" data-slug="kennycoder" data-color="#FFDD00" data-emoji=""  data-font="Cookie" data-text="Buy me a coffee" data-outline-color="#000000" data-font-color="#000000" data-coffee-color="#ffffff" >
  </script>
<div>
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>作者： </strong>KennyChen
  </li>
  <li class="post-copyright-link">
      <strong>文章連結：</strong>
      <a href="https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-%E7%AD%86%E8%A8%98/" title="Hardware Memory Models - 筆記">https://blog.kennycoder.io/2022/07/18/Hardware-Memory-Models-筆記/</a>
  </li>
  <li class="post-copyright-license">
      <strong>版權聲明： </strong>本網誌所有文章除特別聲明外，均採用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 許可協議。轉載請註明出處！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Notes/" rel="tag"># Notes</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/09/Protobuf-%E5%A6%82%E4%BD%95%E9%96%8B%E7%99%BC-codegen-plugin/" rel="prev" title="Protobuf - 如何開發 codegen plugin">
                  <i class="fa fa-angle-left"></i> Protobuf - 如何開發 codegen plugin
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/26/Programming-Language-Memory-Models-%E7%AD%86%E8%A8%98/" rel="next" title="Programming Language Memory Models - 筆記">
                  Programming Language Memory Models - 筆記 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    
  <div class="comments" id="disqus_thread">
    <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
  </div>
  
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="fa fa-user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Kenny - 轉載文章時請附上作者(Kenny)及原文連結(URL)</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="總字數">687k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="所需總閱讀時間">20:49</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="回到頂端">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/KennyChenFight" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.1/dist/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>







  




<script class="next-config" data-name="disqus" type="application/json">{"enable":true,"shortname":"kennychen-blog","count":true,"i18n":{"disqus":"disqus"}}</script>
<script src="/js/third-party/comments/disqus.js"></script>

</body>
</html>
