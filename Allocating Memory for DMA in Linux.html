<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta content="no-referer-when-downgrade" name="referer"><meta content="width=device-width,initial-scale=1" name="viewport"><link href="/apple-touch-icon.png" rel="apple-touch-icon" sizes="76x76"><link href="/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png"><link href="/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png"><link href="/site.webmanifest" rel="manifest"><link href="/safari-pinned-tab.svg" rel="mask-icon" color="#12304c"><meta content="#12304e" name="msapplication-TileColor"><meta content="#12304e" name="theme-color"><script type="application/ld+json">{
        "@context": "https://schema.org",
        "@type": "WebSite",
        "name": "Blake Rain",
        "url": "https://blakerain.com"
      }</script><script id="head-ssg-before"></script><!--<[]>--><title>Allocating Memory for DMA in Linux</title><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","accountablePerson":{"@type":"Person","name":"Blake Rain","url":"https://blakerain.com"},"alternativeHeadline":"In this post we take a look at allocating memory on Linux using huge pages with the intention of\nsharing that memory with PCIe devices that use DMA.","author":{"@type":"Person","name":"Blake Rain","url":"https://blakerain.com"},"creator":{"@type":"Person","name":"Blake Rain","url":"https://blakerain.com"},"dateCreated":"2020-12-11T18:30:00Z","dateModified":"2020-12-11T18:30:00Z","datePublished":"2020-12-11T18:30:00Z","headline":"Allocating Memory for DMA in Linux","image":"https://blakerain.com/content/allocating-memory-for-dma-in-linux/cover.jpg","inLanguage":"en-GB","isFamilyFriendly":"true","keywords":["PCI","Linux","C++"],"publisher":{"@type":"Organisation","logo":{"@type":"ImageObject","height":"56","url":"https://blakerain.com/media/logo-text.png","width":"300"},"name":"Blake Rain","url":"https://blakerain.com"},"url":"https://blakerain.com/blog/allocating-memory-for-dma-in-linux"}</script><meta name="description" content="In this post we take a look at allocating memory on Linux using huge pages with the intention of
sharing that memory with PCIe devices that use DMA."><meta property="og:description" content="In this post we take a look at allocating memory on Linux using huge pages with the intention of
sharing that memory with PCIe devices that use DMA."><meta property="og:type" content="article"><meta property="og:title" content="Allocating Memory for DMA in Linux"><meta property="og:url" content="https://blakerain.com/blog/allocating-memory-for-dma-in-linux"><meta property="og:image" content="https://blakerain.com/content/allocating-memory-for-dma-in-linux/cover.jpg"><meta property="og:image:alt" content="Allocating Memory for DMA in Linux"><meta property="article:published_time" content="2020-12-11T18:30:00Z"><meta property="article:author" content="Blake Rain"><meta property="article:tag" content="PCI"><meta property="article:tag" content="Linux"><meta property="article:tag" content="C++"><link rel="canonical" href="https://blakerain.com/blog/allocating-memory-for-dma-in-linux"><!--</[]>--><script id="head-ssg-after"></script><script type="module">import init from '/site-dc915905fe1d9f61.js';init('/site-dc915905fe1d9f61_bg.wasm');</script><style type="text/css">/*! tailwindcss v3.3.5 | MIT License | https://tailwindcss.com*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-feature-settings:normal;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-variation-settings:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{font-feature-settings:inherit;color:inherit;font-family:inherit;font-size:100%;font-variation-settings:inherit;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::-moz-placeholder,textarea::-moz-placeholder{color:#9ca3af;opacity:1}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]{display:none}[multiple],[type=date],[type=datetime-local],[type=email],[type=month],[type=number],[type=password],[type=search],[type=tel],[type=text],[type=time],[type=url],[type=week],input:where(:not([type])),select,textarea{--tw-shadow:0 0 #0000;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#fff;border-color:#6b7280;border-radius:0;border-width:1px;font-size:1rem;line-height:1.5rem;padding:.5rem .75rem}[multiple]:focus,[type=date]:focus,[type=datetime-local]:focus,[type=email]:focus,[type=month]:focus,[type=number]:focus,[type=password]:focus,[type=search]:focus,[type=tel]:focus,[type=text]:focus,[type=time]:focus,[type=url]:focus,[type=week]:focus,input:where(:not([type])):focus,select:focus,textarea:focus{--tw-ring-inset:var(--tw-empty,/*!*/ /*!*/);--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:#2563eb;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);border-color:#2563eb;box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);outline:2px solid transparent;outline-offset:2px}input::-moz-placeholder,textarea::-moz-placeholder{color:#6b7280;opacity:1}input::placeholder,textarea::placeholder{color:#6b7280;opacity:1}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-date-and-time-value{min-height:1.5em;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit,::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-meridiem-field,::-webkit-datetime-edit-millisecond-field,::-webkit-datetime-edit-minute-field,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-second-field,::-webkit-datetime-edit-year-field{padding-bottom:0;padding-top:0}select{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3E%3C/svg%3E");background-position:right .5rem center;background-repeat:no-repeat;background-size:1.5em 1.5em;padding-right:2.5rem;-webkit-print-color-adjust:exact;print-color-adjust:exact}[multiple],[size]:where(select:not([size="1"])){background-image:none;background-position:0 0;background-repeat:unset;background-size:initial;padding-right:.75rem;-webkit-print-color-adjust:unset;print-color-adjust:unset}[type=checkbox],[type=radio]{--tw-shadow:0 0 #0000;-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:#fff;background-origin:border-box;border-color:#6b7280;border-width:1px;color:#2563eb;display:inline-block;flex-shrink:0;height:1rem;padding:0;-webkit-print-color-adjust:exact;print-color-adjust:exact;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;width:1rem}[type=checkbox]{border-radius:0}[type=radio]{border-radius:100%}[type=checkbox]:focus,[type=radio]:focus{--tw-ring-inset:var(--tw-empty,/*!*/ /*!*/);--tw-ring-offset-width:2px;--tw-ring-offset-color:#fff;--tw-ring-color:#2563eb;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow);outline:2px solid transparent;outline-offset:2px}[type=checkbox]:checked,[type=radio]:checked{background-color:currentColor;background-position:50%;background-repeat:no-repeat;background-size:100% 100%;border-color:transparent}[type=checkbox]:checked{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 16 16'%3E%3Cpath d='M12.207 4.793a1 1 0 0 1 0 1.414l-5 5a1 1 0 0 1-1.414 0l-2-2a1 1 0 0 1 1.414-1.414L6.5 9.086l4.293-4.293a1 1 0 0 1 1.414 0z'/%3E%3C/svg%3E")}[type=radio]:checked{background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' viewBox='0 0 16 16'%3E%3Ccircle cx='8' cy='8' r='3'/%3E%3C/svg%3E")}[type=checkbox]:checked:focus,[type=checkbox]:checked:hover,[type=radio]:checked:focus,[type=radio]:checked:hover{background-color:currentColor;border-color:transparent}[type=checkbox]:indeterminate{background-color:currentColor;background-image:url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 16 16'%3E%3Cpath stroke='%23fff' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M4 8h8'/%3E%3C/svg%3E");background-position:50%;background-repeat:no-repeat;background-size:100% 100%;border-color:transparent}[type=checkbox]:indeterminate:focus,[type=checkbox]:indeterminate:hover{background-color:currentColor;border-color:transparent}[type=file]{background:unset;border-color:inherit;border-radius:0;border-width:0;font-size:unset;line-height:inherit;padding:0}[type=file]:focus{outline:1px solid ButtonText;outline:1px auto -webkit-focus-ring-color}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.container{width:100%}@media (min-width:640px){.container{max-width:640px}}@media (min-width:768px){.container{max-width:768px}}@media (min-width:1024px){.container{max-width:1024px}}@media (min-width:1280px){.container{max-width:1280px}}@media (min-width:1536px){.container{max-width:1536px}}body{--tw-bg-opacity:1;--tw-text-opacity:1;background-color:rgb(255 255 255/var(--tw-bg-opacity));color:rgb(38 38 38/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){body{--tw-bg-opacity:1;--tw-text-opacity:1;background-color:rgb(24 24 27/var(--tw-bg-opacity));color:rgb(229 229 229/var(--tw-text-opacity))}}.button{--tw-text-opacity:1;align-items:center;border-color:transparent;border-radius:.375rem;border-width:1px;color:rgb(229 229 229/var(--tw-text-opacity));display:inline-flex;font-size:.875rem;justify-content:center;line-height:1.25rem;padding:.5rem 1rem}.button:hover{--tw-text-opacity:1;color:rgb(245 245 245/var(--tw-text-opacity))}.button:disabled{--tw-text-opacity:1;color:rgb(156 163 175/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){.button:disabled{--tw-text-opacity:1;color:rgb(31 41 55/var(--tw-text-opacity))}}.button{--tw-bg-opacity:1;background-color:rgb(19 48 78/var(--tw-bg-opacity))}.button:disabled{--tw-bg-opacity:1;background-color:rgb(229 231 235/var(--tw-bg-opacity))}@media (prefers-color-scheme:dark){.button:disabled{--tw-bg-opacity:1;background-color:rgb(75 85 99/var(--tw-bg-opacity))}}.button:active{--tw-bg-opacity:1;background-color:rgb(28 71 115/var(--tw-bg-opacity))}.button:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);--tw-ring-color:rgb(19 48 78/var(--tw-ring-opacity));--tw-ring-opacity:0.5;--tw-ring-offset-width:2px;box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000);outline:2px solid transparent;outline-offset:2px}.button{transition-duration:.15s;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1)}.button>svg{margin-right:.25rem}label{font-weight:600}input[type=number],input[type=password],input[type=text],select{--tw-border-opacity:1;border-color:rgb(19 48 78/var(--tw-border-opacity));border-radius:.375rem}input[type=number]:disabled,input[type=password]:disabled,input[type=text]:disabled,select:disabled{border-color:transparent}input[type=number],input[type=password],input[type=text],select{--tw-text-opacity:1;color:rgb(38 38 38/var(--tw-text-opacity))}input[type=number]::-moz-placeholder,input[type=password]::-moz-placeholder,input[type=text]::-moz-placeholder,select::-moz-placeholder{--tw-text-opacity:1;color:rgb(212 212 212/var(--tw-text-opacity));color:rgb(115 115 115/var(--tw-text-opacity))}input[type=number]::placeholder,input[type=password]::placeholder,input[type=text]::placeholder,select::placeholder{--tw-text-opacity:1;color:rgb(212 212 212/var(--tw-text-opacity));color:rgb(115 115 115/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){input[type=number],input[type=password],input[type=text],select{--tw-text-opacity:1;color:rgb(229 229 229/var(--tw-text-opacity))}}input[type=number]:disabled,input[type=password]:disabled,input[type=text]:disabled,select:disabled{--tw-text-opacity:1;color:rgb(156 163 175/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){input[type=number]:disabled,input[type=password]:disabled,input[type=text]:disabled,select:disabled{--tw-text-opacity:1;color:rgb(31 41 55/var(--tw-text-opacity))}}input[type=number],input[type=password],input[type=text],select{--tw-bg-opacity:1;background-color:rgb(255 255 255/var(--tw-bg-opacity))}@media (prefers-color-scheme:dark){input[type=number],input[type=password],input[type=text],select{--tw-bg-opacity:1;background-color:rgb(39 39 42/var(--tw-bg-opacity))}}input[type=number]:disabled,input[type=password]:disabled,input[type=text]:disabled,select:disabled{--tw-bg-opacity:1;background-color:rgb(229 231 235/var(--tw-bg-opacity))}@media (prefers-color-scheme:dark){input[type=number]:disabled,input[type=password]:disabled,input[type=text]:disabled,select:disabled{--tw-bg-opacity:1;background-color:rgb(75 85 99/var(--tw-bg-opacity))}}input[type=number]:focus,input[type=password]:focus,input[type=text]:focus,select:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);--tw-ring-color:rgb(19 48 78/var(--tw-ring-opacity));--tw-ring-opacity:0.5;--tw-ring-offset-width:2px;box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000);outline:2px solid transparent;outline-offset:2px}input[type=number],input[type=password],input[type=text],select{transition-duration:.15s;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1)}.input-icons{position:relative}.input-icons svg:first-child,.input-icons svg:last-child{--tw-text-opacity:1;color:rgb(209 213 219/var(--tw-text-opacity));margin-top:-.625rem;pointer-events:none;position:absolute;top:50%}@media (prefers-color-scheme:dark){.input-icons svg:first-child,.input-icons svg:last-child{--tw-text-opacity:1;color:rgb(107 114 128/var(--tw-text-opacity))}}.input-icons svg:first-child{left:.75rem}.input-icons svg:last-child{right:.75rem}.input-icons input[type=number].icon-left,.input-icons input[type=password].icon-left,.input-icons input[type=text].icon-left,.input-icons select.icon-left{padding-left:2.5rem}.input-icons input[type=number].icon-right,.input-icons input[type=password].icon-right,.input-icons input[type=text].icon-right,.input-icons select.icon-right{padding-right:2.5rem}.toggle{cursor:pointer;display:block;height:var(--toggle-size);position:relative;width:calc(var(--toggle-size)*2)}.toggle.active .toggle-background{--tw-bg-opacity:1;background-color:rgb(30 41 59/var(--tw-bg-opacity))}@media (prefers-color-scheme:dark){.toggle.active .toggle-background{--tw-bg-opacity:1;background-color:rgb(165 180 252/var(--tw-bg-opacity))}}.toggle.active .toggle-inner{right:0}.toggle .toggle-background{--tw-bg-opacity:1;background-color:rgb(203 213 225/var(--tw-bg-opacity));position:absolute}@media (prefers-color-scheme:dark){.toggle .toggle-background{--tw-bg-opacity:1;background-color:rgb(75 85 99/var(--tw-bg-opacity))}}.toggle .toggle-background{border-radius:calc(var(--toggle-size)*.5);height:calc(var(--toggle-size)*.5);top:calc(var(--toggle-size)*.25);transition:background-color .125s ease-in-out;width:calc(var(--toggle-size)*2)}.toggle .toggle-inner{--tw-bg-opacity:1;background-color:rgb(255 255 255/var(--tw-bg-opacity));border:1px solid rgba(0,0,0,.25);border-radius:calc(var(--toggle-size)*.5);box-shadow:1px 1px 2px rgba(0,0,0,.25);height:var(--toggle-size);position:absolute;right:var(--toggle-size);top:0;transition:right .125s ease-in-out;width:var(--toggle-size)}.tooltip{--tw-text-opacity:1;--tw-border-opacity:1;--tw-bg-opacity:1;--tw-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -2px rgba(0,0,0,.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color),0 2px 4px -2px var(--tw-shadow-color);background-color:rgb(19 48 78/var(--tw-bg-opacity));border-color:rgb(19 48 78/var(--tw-border-opacity));border-radius:.375rem;border-width:1px;box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow);color:rgb(250 250 250/var(--tw-text-opacity));font-size:.875rem;line-height:1.25rem;max-width:20rem;min-height:-moz-fit-content;min-height:fit-content;padding:1rem;position:absolute;text-align:center;white-space:pre-wrap;width:-moz-max-content;width:max-content;z-index:10}.tooltip:after{content:"";height:0;position:absolute;width:0}.tooltip.\!top,.tooltip.top{--tw-translate-x:-50%;bottom:100%;left:50%;margin-bottom:1rem;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.tooltip.\!top:after,.tooltip.top:after{left:50%;margin-left:-1rem;top:100%}.tooltip.top:after{border-left:1rem solid transparent;border-right:1rem solid transparent;border-top:1rem solid var(--primary-color)}.tooltip.\!top:after{border-left:1rem solid transparent!important;border-right:1rem solid transparent!important;border-top:1rem solid var(--primary-color)!important}.tooltip.bottom{--tw-translate-x:-50%;left:50%;margin-top:1rem;top:100%;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.tooltip.bottom:after{border-bottom:1rem solid var(--primary-color);border-left:1rem solid transparent;border-right:1rem solid transparent;bottom:100%;left:50%;margin-left:-1rem}.tooltip.left{margin-right:1rem;right:100%;top:-.75rem}.tooltip.left:after{border-bottom:1rem solid transparent;border-left:1rem solid var(--primary-color);border-top:1rem solid transparent;left:100%;margin-right:1rem;top:.375rem}.tooltip.right{left:100%;margin-left:1rem;top:-.75rem}.tooltip.right:after{border-bottom:1rem solid transparent;border-right:1rem solid var(--primary-color);border-top:1rem solid transparent;margin-left:1rem;right:100%;top:.375rem}.markdown{display:flex;flex-direction:column;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-size:1.125rem;font-weight:400;line-height:1.75rem}@media print{.markdown{font-size:1rem;line-height:1.5rem}}.markdown{--tw-text-opacity:1;color:rgb(38 38 38/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){.markdown{--tw-text-opacity:1;color:rgb(212 212 212/var(--tw-text-opacity))}}.markdown{counter-reset:h1-outline-counter}.markdown.numbered-headings h1:not(.no-outline){counter-increment:h1-outline-counter;counter-reset:h2-outline-counter}.markdown.numbered-headings h1:not(.no-outline):before{content:counter(h1-outline-counter) ". "}.markdown.numbered-headings h2:not(.no-outline){counter-increment:h2-outline-counter;counter-reset:h3-outline-counter}.markdown.numbered-headings h2:not(.no-outline):before{content:counter(h1-outline-counter) "." counter(h2-outline-counter) " "}.markdown.numbered-headings h3:not(.no-outline){counter-increment:h3-outline-counter;counter-reset:h4-outline-counter}.markdown.numbered-headings h3:not(.no-outline):before{content:counter(h1-outline-counter) "." counter(h2-outline-counter) "." counter(h3-outline-counter) " "}.markdown.numbered-headings h4:not(.no-outline){counter-increment:h4-outline-counter;counter-reset:h5-outline-counter}.markdown.numbered-headings h4:not(.no-outline):before{content:counter(h1-outline-counter) "." counter(h2-outline-counter) "." counter(h3-outline-counter) "." counter(h4-outline-counter) " "}.markdown.numbered-headings h5:not(.no-outline){counter-increment:h5-outline-counter;counter-reset:h6-outline-counter}.markdown.numbered-headings h5:not(.no-outline):before{content:counter(h1-outline-counter) "." counter(h2-outline-counter) "." counter(h3-outline-counter) "." counter(h4-outline-counter) "." counter(h5-outline-counter) " "}.markdown.numbered-headings h6:not(.no-outline){counter-increment:h6-outline-counter}.markdown.numbered-headings h6:not(.no-outline):before{content:counter(h1-outline-counter) "." counter(h2-outline-counter) "." counter(h3-outline-counter) "." counter(h4-outline-counter) "." counter(h5-outline-counter) "." counter(h6-outline-counter) " "}.markdown h1,.markdown h2,.markdown h3,.markdown h4,.markdown h5,.markdown h6{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;width:100%}.markdown h1.with-anchor,.markdown h2.with-anchor,.markdown h3.with-anchor,.markdown h4.with-anchor,.markdown h5.with-anchor,.markdown h6.with-anchor{position:relative}.markdown h1.with-anchor>a,.markdown h2.with-anchor>a,.markdown h3.with-anchor>a,.markdown h4.with-anchor>a,.markdown h5.with-anchor>a,.markdown h6.with-anchor>a{--tw-text-opacity:1;color:rgb(107 114 128/var(--tw-text-opacity));display:none;left:-2.5rem;padding-right:.5rem;position:absolute;top:.625rem}@media (prefers-color-scheme:dark){.markdown h1.with-anchor>a,.markdown h2.with-anchor>a,.markdown h3.with-anchor>a,.markdown h4.with-anchor>a,.markdown h5.with-anchor>a,.markdown h6.with-anchor>a{--tw-text-opacity:1;color:rgb(156 163 175/var(--tw-text-opacity))}}.markdown h1.with-anchor>a:hover,.markdown h2.with-anchor>a:hover,.markdown h3.with-anchor>a:hover,.markdown h4.with-anchor>a:hover,.markdown h5.with-anchor>a:hover,.markdown h6.with-anchor>a:hover{--tw-text-opacity:1;color:rgb(156 163 175/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){.markdown h1.with-anchor>a:hover,.markdown h2.with-anchor>a:hover,.markdown h3.with-anchor>a:hover,.markdown h4.with-anchor>a:hover,.markdown h5.with-anchor>a:hover,.markdown h6.with-anchor>a:hover{--tw-text-opacity:1;color:rgb(209 213 219/var(--tw-text-opacity))}}.markdown h1.with-anchor>a>svg,.markdown h2.with-anchor>a>svg,.markdown h3.with-anchor>a>svg,.markdown h4.with-anchor>a>svg,.markdown h5.with-anchor>a>svg,.markdown h6.with-anchor>a>svg{height:2rem;width:2rem}.markdown h2.with-anchor>a{top:.375rem}.markdown h1+figure,.markdown h2+figure,.markdown h3+figure,.markdown h4+figure{margin-top:.75rem}.markdown h1{font-size:3rem;font-weight:400;line-height:1;margin-bottom:1rem;margin-top:2rem}@media print{.markdown h1{font-size:1.875rem;line-height:2.25rem}}.markdown h2{font-size:2.25rem;font-weight:400;line-height:2.5rem;margin-bottom:1rem;margin-top:2rem}.markdown h3{font-size:1.875rem;line-height:2.25rem;margin-bottom:.75rem}.markdown h3,.markdown h4{font-weight:400;margin-top:1.5rem}.markdown h4{font-size:1.5rem;line-height:2rem;margin-bottom:.5rem}.markdown h6{font-size:1.25rem;font-weight:400;line-height:1.75rem;margin-bottom:.5rem;margin-top:1rem}.markdown p{line-height:1.625;margin-bottom:1.5rem;width:100%}.markdown a:not(.plain){--tw-text-opacity:1;color:rgb(59 130 246/var(--tw-text-opacity));text-decoration-line:underline}@media (prefers-color-scheme:dark){.markdown a:not(.plain){--tw-text-opacity:1;color:rgb(191 219 254/var(--tw-text-opacity))}}.markdown a:not(.plain):hover{--tw-text-opacity:1;color:rgb(37 99 235/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){.markdown a:not(.plain):hover{--tw-text-opacity:1;color:rgb(147 197 253/var(--tw-text-opacity))}}.markdown .footnote{--tw-text-opacity:1;color:rgb(107 114 128/var(--tw-text-opacity));display:flex;flex-direction:row;font-size:1rem;gap:.25rem;line-height:1.5rem;margin-bottom:1.5rem}@media (prefers-color-scheme:dark){.markdown .footnote{--tw-text-opacity:1;color:rgb(156 163 175/var(--tw-text-opacity))}}.markdown .footnote:has(+.footnote){margin-bottom:0}.markdown .footnote div.footnote-index{line-height:1.625;margin-right:.5rem}.markdown .footnote div.footnote-index:after{content:"."}.markdown .footnote p:last-child{margin-bottom:0}.markdown dl,.markdown ol,.markdown ul{align-self:flex-start;margin-bottom:1.5rem;width:100%}.markdown dl li,.markdown ol li,.markdown ul li{margin-top:.625rem;overflow-wrap:break-word;padding-left:.375rem}.markdown dl li:first-child,.markdown ol li:first-child,.markdown ul li:first-child{margin-top:0}.markdown ol{list-style-type:decimal;padding-left:2.5rem}.markdown ul{list-style-type:disc;padding-left:2.5rem}.markdown figure{align-items:center;display:flex;flex-direction:column;margin-bottom:1.5rem;width:100%}.markdown figure pre{--tw-bg-opacity:1;background-color:rgb(245 245 245/var(--tw-bg-opacity));border-radius:.375rem;overflow-x:scroll;padding:1rem;width:100%}@media (prefers-color-scheme:dark){.markdown figure pre{--tw-bg-opacity:1;background-color:rgb(38 38 38/var(--tw-bg-opacity))}}@media print{.markdown figure pre{--tw-border-opacity:1;border-color:rgb(38 38 38/var(--tw-border-opacity));padding:.5rem}}.markdown figure pre code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;line-height:1.375}.markdown figure.quote{align-items:flex-start;position:relative}.markdown figure.quote:before{--tw-text-opacity:1;color:rgb(163 163 163/var(--tw-text-opacity));content:"“";font-size:6rem;left:-44px;position:absolute;top:24px}@media (prefers-color-scheme:dark){.markdown figure.quote:before{--tw-text-opacity:1;color:rgb(64 64 64/var(--tw-text-opacity))}}.markdown figure.quote:before{display:none}@media (min-width:768px){.markdown figure.quote:before{display:block}}.markdown figure.quote p{--tw-text-opacity:1;color:rgb(82 82 82/var(--tw-text-opacity));font-style:italic;margin-bottom:0}@media (prefers-color-scheme:dark){.markdown figure.quote p{--tw-text-opacity:1;color:rgb(163 163 163/var(--tw-text-opacity))}}.markdown figure.quote cite:before{content:"— "}.markdown figure.quote cite{margin-left:1rem}.markdown figcaption,.markdown figure.quote cite{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.markdown figcaption{--tw-text-opacity:1;color:rgb(82 82 82/var(--tw-text-opacity));font-size:.875rem;line-height:1.25rem;margin-top:1rem;text-align:center}@media (prefers-color-scheme:dark){.markdown figcaption{--tw-text-opacity:1;color:rgb(163 163 163/var(--tw-text-opacity))}}.markdown div.table{margin-bottom:1.5rem}.markdown blockquote{--tw-border-opacity:1;border-left-color:rgb(96 165 250/var(--tw-border-opacity));border-left-width:4px;margin-bottom:1.5rem;padding-left:2rem;padding-right:2rem;width:100%}.markdown blockquote p{--tw-text-opacity:1;color:rgb(82 82 82/var(--tw-text-opacity));font-style:italic}@media (prefers-color-scheme:dark){.markdown blockquote p{--tw-text-opacity:1;color:rgb(163 163 163/var(--tw-text-opacity))}}.markdown blockquote p:last-child{margin-bottom:0}.markdown .callout{border-radius:.375rem;display:flex;flex-direction:column;font-size:1rem;gap:.5rem;line-height:1.5rem;margin-bottom:1.5rem;padding:1rem}@media print{.markdown .callout{border-width:2px;padding:.5rem}}.markdown .callout>.heading{display:flex;flex-direction:row;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;gap:.25rem}.markdown .callout>.heading>svg{width:1.2rem}.markdown .callout>.heading>div{font-weight:700}.markdown .callout>.body p:last-child{margin-bottom:0}.markdown .callout.note{--tw-bg-opacity:1;background-color:rgb(191 219 254/var(--tw-bg-opacity))}@media (prefers-color-scheme:dark){.markdown .callout.note{--tw-bg-opacity:1;background-color:rgb(23 37 84/var(--tw-bg-opacity))}}@media print{.markdown .callout.note{--tw-border-opacity:1;background-color:transparent;border-color:rgb(191 219 254/var(--tw-border-opacity))}}.markdown .callout.note>.heading{--tw-text-opacity:1;color:rgb(37 99 235/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){.markdown .callout.note>.heading{--tw-text-opacity:1;color:rgb(59 130 246/var(--tw-text-opacity))}}.markdown .callout.note>.body{--tw-text-opacity:1;color:rgb(0 0 0/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){.markdown .callout.note>.body{--tw-text-opacity:1;color:rgb(255 255 255/var(--tw-text-opacity))}}.markdown .callout.tip{--tw-bg-opacity:1;background-color:rgb(204 251 241/var(--tw-bg-opacity))}@media (prefers-color-scheme:dark){.markdown .callout.tip{--tw-bg-opacity:1;background-color:rgb(19 78 74/var(--tw-bg-opacity))}}@media print{.markdown .callout.tip{--tw-border-opacity:1;background-color:transparent;border-color:rgb(19 78 74/var(--tw-border-opacity))}}.markdown .callout.tip>.heading{--tw-text-opacity:1;color:rgb(13 148 136/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){.markdown .callout.tip>.heading{--tw-text-opacity:1;color:rgb(94 234 212/var(--tw-text-opacity))}}.markdown .callout.success{--tw-bg-opacity:1;background-color:rgb(220 252 231/var(--tw-bg-opacity))}@media (prefers-color-scheme:dark){.markdown .callout.success{--tw-bg-opacity:1;background-color:rgb(20 83 45/var(--tw-bg-opacity))}}@media print{.markdown .callout.success{--tw-border-opacity:1;background-color:transparent;border-color:rgb(20 83 45/var(--tw-border-opacity))}}.markdown .callout.success>.heading{--tw-text-opacity:1;color:rgb(22 163 74/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){.markdown .callout.success>.heading{--tw-text-opacity:1;color:rgb(74 222 128/var(--tw-text-opacity))}}.markdown .callout.question{background-color:hsla(48,97%,77%,.1)}@media print{.markdown .callout.question{--tw-border-opacity:1;background-color:transparent;border-color:rgb(245 158 11/var(--tw-border-opacity))}}.markdown .callout.question>.heading{--tw-text-opacity:1;color:rgb(245 158 11/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){.markdown .callout.question>.heading{--tw-text-opacity:1;color:rgb(253 230 138/var(--tw-text-opacity))}}.markdown .callout.warning{background-color:rgba(249,115,22,.1)}@media print{.markdown .callout.warning{--tw-border-opacity:1;background-color:transparent;border-color:rgb(249 115 22/var(--tw-border-opacity))}}.markdown .callout.warning>.heading{--tw-text-opacity:1;color:rgb(234 88 12/var(--tw-text-opacity))}.markdown .callout.danger{background-color:rgba(239,68,68,.25)}@media print{.markdown .callout.danger{--tw-border-opacity:1;background-color:transparent;border-color:rgb(239 68 68/var(--tw-border-opacity))}}.markdown .callout.danger>.heading{--tw-text-opacity:1;color:rgb(239 68 68/var(--tw-text-opacity))}.markdown .callout.example{background-color:rgba(76,29,149,.25)}@media print{.markdown .callout.example{--tw-border-opacity:1;background-color:transparent;border-color:rgb(76 29 149/var(--tw-border-opacity))}}.markdown .callout.example>.heading{--tw-text-opacity:1;color:rgb(124 58 237/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){.markdown .callout.example>.heading{--tw-text-opacity:1;color:rgb(167 139 250/var(--tw-text-opacity))}}div.table{display:flex;overflow-x:scroll}table{border-collapse:collapse;min-width:100%;table-layout:auto}table thead{background-color:transparent}@media (prefers-color-scheme:dark){table thead{--tw-bg-opacity:1;--tw-text-opacity:1;background-color:rgb(38 38 38/var(--tw-bg-opacity));color:rgb(255 255 255/var(--tw-text-opacity))}}table thead tr th{padding:1rem 1.5rem}table thead tr th.left{text-align:left}table thead tr th.right{text-align:right}table thead tr th.center{text-align:center}table tbody tr td{padding:1rem 1.5rem;white-space:nowrap}table tbody tr td.left{text-align:left}table tbody tr td.right{text-align:right}table tbody tr td.center{text-align:center}table.tight tbody tr td,table.tight thead tr th{padding:.5rem .75rem}table.tighter tbody tr td,table.tighter thead tr th{padding:.25rem}table:not(.borderless) thead{--tw-border-opacity:1;border-bottom-width:1px;border-color:rgb(115 115 115/var(--tw-border-opacity))}table:not(.borderless) tbody tr{--tw-border-opacity:1;border-bottom-width:1px;border-color:rgb(163 163 163/var(--tw-border-opacity))}@media (prefers-color-scheme:dark){table:not(.borderless) tbody tr{--tw-border-opacity:1;border-color:rgb(82 82 82/var(--tw-border-opacity))}}.sr-only{clip:rect(0,0,0,0);border-width:0;height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.pointer-events-none{pointer-events:none}.visible{visibility:visible}.static{position:static}.fixed{position:fixed}.absolute{position:absolute}.relative{position:relative}.-left-10{left:-2.5rem}.-top-3{top:-.75rem}.bottom-8{bottom:2rem}.bottom-full{bottom:100%}.left-0{left:0}.left-1\/2{left:50%}.left-full{left:100%}.right-8{right:2rem}.right-full{right:100%}.top-0{top:0}.top-1{top:.25rem}.top-1\.5{top:.375rem}.top-1\/2{top:50%}.top-2{top:.5rem}.top-2\.5{top:.625rem}.top-full{top:100%}.z-10{z-index:10}.col-start-1{grid-column-start:1}.mx-2{margin-left:.5rem;margin-right:.5rem}.mx-5{margin-left:1.25rem;margin-right:1.25rem}.mx-auto{margin-left:auto;margin-right:auto}.my-10{margin-bottom:2.5rem;margin-top:2.5rem}.my-12{margin-bottom:3rem;margin-top:3rem}.my-4{margin-bottom:1rem;margin-top:1rem}.my-8{margin-bottom:2rem;margin-top:2rem}.-mt-2{margin-top:-.5rem}.-mt-2\.5{margin-top:-.625rem}.mb-10{margin-bottom:2.5rem}.mb-20{margin-bottom:5rem}.mb-6{margin-bottom:1.5rem}.ml-auto{margin-left:auto}.mr-2{margin-right:.5rem}.mr-3{margin-right:.75rem}.mr-4{margin-right:1rem}.mt-10{margin-top:2.5rem}.mt-2{margin-top:.5rem}.mt-2\.5{margin-top:.625rem}.mt-20{margin-top:5rem}.mt-3{margin-top:.75rem}.mt-3\.5{margin-top:.875rem}.mt-4{margin-top:1rem}.mt-6{margin-top:1.5rem}.mt-8{margin-top:2rem}.block{display:block}.inline-block{display:inline-block}.inline{display:inline}.flex{display:flex}.inline-flex{display:inline-flex}.table{display:table}.grid{display:grid}.hidden{display:none}.h-\[18px\]{height:18px}.h-\[240px\]{height:240px}.h-full{height:100%}.max-h-12{max-height:3rem}.max-h-\[100\%\]{max-height:100%}.min-h-\[10rem\]{min-height:10rem}.min-h-\[148px\]{min-height:148px}.min-h-\[160px\]{min-height:160px}.min-h-fit{min-height:-moz-fit-content;min-height:fit-content}.w-0{width:0}.w-8{width:2rem}.w-\[1\.2rem\]{width:1.2rem}.w-\[18px\]{width:18px}.w-full{width:100%}.w-max{width:-moz-max-content;width:max-content}.min-w-\[33\%\]{min-width:33%}.min-w-full{min-width:100%}.max-w-xs{max-width:20rem}.grow{flex-grow:1}.border-collapse{border-collapse:collapse}.-translate-x-1\/2{--tw-translate-x:-50%}.-translate-x-1\/2,.transform{transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))}.cursor-pointer{cursor:pointer}.list-decimal{list-style-type:decimal}.list-disc{list-style-type:disc}.grid-flow-col{grid-auto-flow:column}.grid-cols-1{grid-template-columns:repeat(1,minmax(0,1fr))}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.flex-row{flex-direction:row}.flex-col{flex-direction:column}.flex-wrap{flex-wrap:wrap}.items-center{align-items:center}.justify-start{justify-content:flex-start}.justify-between{justify-content:space-between}.justify-stretch{justify-content:stretch}.gap-1{gap:.25rem}.gap-2{gap:.5rem}.gap-4{gap:1rem}.gap-8{gap:2rem}.gap-x-10{-moz-column-gap:2.5rem;column-gap:2.5rem}.self-start{align-self:flex-start}.overflow-y-hidden{overflow-y:hidden}.whitespace-nowrap{white-space:nowrap}.break-words{overflow-wrap:break-word}.rounded-md{border-radius:.375rem}.rounded-xl{border-radius:.75rem}.rounded-r-md{border-bottom-right-radius:.375rem;border-top-right-radius:.375rem}.border{border-width:1px}.border-b{border-bottom-width:1px}.border-l-4{border-left-width:4px}.border-neutral-300{--tw-border-opacity:1;border-color:rgb(212 212 212/var(--tw-border-opacity))}.border-neutral-400{--tw-border-opacity:1;border-color:rgb(163 163 163/var(--tw-border-opacity))}.border-primary{--tw-border-opacity:1;border-color:rgb(19 48 78/var(--tw-border-opacity))}.border-transparent{border-color:transparent}.border-l-blue-400{--tw-border-opacity:1;border-left-color:rgb(96 165 250/var(--tw-border-opacity))}.bg-amber-200\/10{background-color:hsla(48,97%,77%,.1)}.bg-blue-200{--tw-bg-opacity:1;background-color:rgb(191 219 254/var(--tw-bg-opacity))}.bg-green-100{--tw-bg-opacity:1;background-color:rgb(220 252 231/var(--tw-bg-opacity))}.bg-neutral-100{--tw-bg-opacity:1;background-color:rgb(245 245 245/var(--tw-bg-opacity))}.bg-orange-500\/10{background-color:rgba(249,115,22,.1)}.bg-primary{--tw-bg-opacity:1;background-color:rgb(19 48 78/var(--tw-bg-opacity))}.bg-red-500\/25{background-color:rgba(239,68,68,.25)}.bg-slate-300{--tw-bg-opacity:1;background-color:rgb(203 213 225/var(--tw-bg-opacity))}.bg-slate-800{--tw-bg-opacity:1;background-color:rgb(30 41 59/var(--tw-bg-opacity))}.bg-teal-100{--tw-bg-opacity:1;background-color:rgb(204 251 241/var(--tw-bg-opacity))}.bg-transparent{background-color:transparent}.bg-violet-900\/25{background-color:rgba(76,29,149,.25)}.bg-white{--tw-bg-opacity:1;background-color:rgb(255 255 255/var(--tw-bg-opacity))}.bg-cover{background-size:cover}.bg-fixed{background-attachment:fixed}.bg-\[50\%\]{background-position:50%}.bg-no-repeat{background-repeat:no-repeat}.fill-black{fill:#000}.fill-slate-700{fill:#334155}.fill-slate-800{fill:#1e293b}.stroke-black{stroke:#000}.object-cover{-o-object-fit:cover;object-fit:cover}.p-4{padding:1rem}.p-5{padding:1.25rem}.px-1{padding-left:.25rem;padding-right:.25rem}.px-16{padding-left:4rem;padding-right:4rem}.px-2{padding-left:.5rem;padding-right:.5rem}.px-3{padding-left:.75rem;padding-right:.75rem}.px-4{padding-left:1rem;padding-right:1rem}.px-6{padding-left:1.5rem;padding-right:1.5rem}.px-8{padding-left:2rem;padding-right:2rem}.py-4{padding-bottom:1rem;padding-top:1rem}.py-6{padding-bottom:1.5rem;padding-top:1.5rem}.pl-1{padding-left:.25rem}.pt-7{padding-top:1.75rem}.pt-8{padding-top:2rem}.text-left{text-align:left}.text-center{text-align:center}.text-right{text-align:right}.font-mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace}.font-sans{font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji}.text-2xl{font-size:1.5rem;line-height:2rem}.text-3xl{font-size:1.875rem;line-height:2.25rem}.text-4xl{font-size:2.25rem;line-height:2.5rem}.text-5xl{font-size:3rem;line-height:1}.text-base{font-size:1rem;line-height:1.5rem}.text-lg{font-size:1.125rem;line-height:1.75rem}.text-sm{font-size:.875rem;line-height:1.25rem}.text-xl{font-size:1.25rem;line-height:1.75rem}.font-bold{font-weight:700}.font-medium{font-weight:500}.font-normal{font-weight:400}.font-semibold{font-weight:600}.uppercase{text-transform:uppercase}.italic{font-style:italic}.leading-relaxed{line-height:1.625}.text-amber-500{--tw-text-opacity:1;color:rgb(245 158 11/var(--tw-text-opacity))}.text-black{--tw-text-opacity:1;color:rgb(0 0 0/var(--tw-text-opacity))}.text-blue-500{--tw-text-opacity:1;color:rgb(59 130 246/var(--tw-text-opacity))}.text-blue-600{--tw-text-opacity:1;color:rgb(37 99 235/var(--tw-text-opacity))}.text-gray-300{--tw-text-opacity:1;color:rgb(209 213 219/var(--tw-text-opacity))}.text-gray-500{--tw-text-opacity:1;color:rgb(107 114 128/var(--tw-text-opacity))}.text-green-600{--tw-text-opacity:1;color:rgb(22 163 74/var(--tw-text-opacity))}.text-neutral-200{--tw-text-opacity:1;color:rgb(229 229 229/var(--tw-text-opacity))}.text-neutral-200\/75{color:hsla(0,0%,90%,.75)}.text-neutral-400{--tw-text-opacity:1;color:rgb(163 163 163/var(--tw-text-opacity))}.text-neutral-50{--tw-text-opacity:1;color:rgb(250 250 250/var(--tw-text-opacity))}.text-neutral-500{--tw-text-opacity:1;color:rgb(115 115 115/var(--tw-text-opacity))}.text-neutral-600{--tw-text-opacity:1;color:rgb(82 82 82/var(--tw-text-opacity))}.text-neutral-800{--tw-text-opacity:1;color:rgb(38 38 38/var(--tw-text-opacity))}.text-red-500{--tw-text-opacity:1;color:rgb(239 68 68/var(--tw-text-opacity))}.text-sky-700{--tw-text-opacity:1;color:rgb(3 105 161/var(--tw-text-opacity))}.text-teal-600{--tw-text-opacity:1;color:rgb(13 148 136/var(--tw-text-opacity))}.text-violet-600{--tw-text-opacity:1;color:rgb(124 58 237/var(--tw-text-opacity))}.text-white{--tw-text-opacity:1;color:rgb(255 255 255/var(--tw-text-opacity))}.underline{text-decoration-line:underline}.opacity-25{opacity:.25}.opacity-50{opacity:.5}.shadow-md{--tw-shadow:0 4px 6px -1px rgba(0,0,0,.1),0 2px 4px -2px rgba(0,0,0,.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color),0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}.transition{transition-duration:.15s;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,-webkit-backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke,opacity,box-shadow,transform,filter,backdrop-filter,-webkit-backdrop-filter;transition-timing-function:cubic-bezier(.4,0,.2,1)}.transition-all{transition-duration:.15s;transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1)}.transition-colors{transition-duration:.15s;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1)}.duration-200{transition-duration:.2s}.duration-300{transition-duration:.3s}:root{--toggle-size:2rem;--primary-color:#13304e}.hover\:bg-primary-dark:hover{--tw-bg-opacity:1;background-color:rgb(34 41 61/var(--tw-bg-opacity))}.hover\:text-blue-600:hover{--tw-text-opacity:1;color:rgb(37 99 235/var(--tw-text-opacity))}.hover\:text-gray-400:hover{--tw-text-opacity:1;color:rgb(156 163 175/var(--tw-text-opacity))}.hover\:text-neutral-200:hover{--tw-text-opacity:1;color:rgb(229 229 229/var(--tw-text-opacity))}.hover\:text-neutral-50:hover{--tw-text-opacity:1;color:rgb(250 250 250/var(--tw-text-opacity))}.hover\:opacity-100:hover{opacity:1}.focus\:outline-none:focus{outline:2px solid transparent;outline-offset:2px}.focus\:ring-2:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow),var(--tw-ring-shadow),var(--tw-shadow,0 0 #0000)}.focus\:ring-opacity-50:focus{--tw-ring-opacity:0.5}.focus\:ring-offset-2:focus{--tw-ring-offset-width:2px}.disabled\:bg-gray-200:disabled{--tw-bg-opacity:1;background-color:rgb(229 231 235/var(--tw-bg-opacity))}.disabled\:text-gray-400:disabled{--tw-text-opacity:1;color:rgb(156 163 175/var(--tw-text-opacity))}.group:focus-within .group-focus-within\:text-indigo-300{--tw-text-opacity:1;color:rgb(165 180 252/var(--tw-text-opacity))}.group:hover .group-hover\:block{display:block}@media (prefers-color-scheme:dark){.dark\:border-neutral-700{--tw-border-opacity:1;border-color:rgb(64 64 64/var(--tw-border-opacity))}.dark\:bg-neutral-800{--tw-bg-opacity:1;background-color:rgb(38 38 38/var(--tw-bg-opacity))}.dark\:bg-zinc-900{--tw-bg-opacity:1;background-color:rgb(24 24 27/var(--tw-bg-opacity))}.dark\:fill-slate-400{fill:#94a3b8}.dark\:fill-slate-500{fill:#64748b}.dark\:fill-white{fill:#fff}.dark\:stroke-white{stroke:#fff}.dark\:text-gray-400{--tw-text-opacity:1;color:rgb(156 163 175/var(--tw-text-opacity))}.dark\:text-neutral-200{--tw-text-opacity:1;color:rgb(229 229 229/var(--tw-text-opacity))}.dark\:text-sky-500{--tw-text-opacity:1;color:rgb(14 165 233/var(--tw-text-opacity))}.dark\:shadow-none{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow,0 0 #0000),var(--tw-ring-shadow,0 0 #0000),var(--tw-shadow)}}@media print{.print\:block{display:block}.print\:hidden{display:none}.print\:max-w-full{max-width:100%}.print\:border-2{border-width:2px}.print\:border-blue-200{--tw-border-opacity:1;border-color:rgb(191 219 254/var(--tw-border-opacity))}.print\:border-green-900{--tw-border-opacity:1;border-color:rgb(20 83 45/var(--tw-border-opacity))}.print\:border-neutral-800{--tw-border-opacity:1;border-color:rgb(38 38 38/var(--tw-border-opacity))}.print\:border-teal-900{--tw-border-opacity:1;border-color:rgb(19 78 74/var(--tw-border-opacity))}.print\:bg-transparent{background-color:transparent}.print\:px-0{padding-left:0;padding-right:0}.print\:text-3xl{font-size:1.875rem;line-height:2.25rem}}@media (min-width:640px){.sm\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.sm\:rounded-t{border-top-left-radius:.25rem;border-top-right-radius:.25rem}.sm\:px-0{padding-left:0;padding-right:0}.sm\:px-16{padding-left:4rem;padding-right:4rem}.sm\:opacity-100{opacity:1}}@media (min-width:768px){.md\:col-start-2{grid-column-start:2}.md\:mx-0{margin-left:0;margin-right:0}.md\:my-0{margin-bottom:0;margin-top:0}.md\:mt-4{margin-top:1rem}.md\:block{display:block}.md\:flex{display:flex}.md\:hidden{display:none}.md\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.md\:flex-row{flex-direction:row}.md\:items-end{align-items:flex-end}.md\:justify-between{justify-content:space-between}.md\:gap-0{gap:0}.md\:opacity-100{opacity:1}.group:hover .md\:group-hover\:text-gray-600{--tw-text-opacity:1;color:rgb(75 85 99/var(--tw-text-opacity))}@media (prefers-color-scheme:dark){.group:hover .md\:dark\:group-hover\:text-gray-300{--tw-text-opacity:1;color:rgb(209 213 219/var(--tw-text-opacity))}}}@media (min-width:1024px){.lg\:order-1{order:1}.lg\:order-2{order:2}.lg\:mt-0{margin-top:0}.lg\:mt-12{margin-top:3rem}.lg\:h-\[22px\]{height:22px}.lg\:min-h-fit{min-height:-moz-fit-content;min-height:fit-content}.lg\:w-2\/3{width:66.666667%}.lg\:w-\[22px\]{width:22px}.lg\:grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.lg\:flex-row{flex-direction:row}.lg\:items-start{align-items:flex-start}.lg\:items-end{align-items:flex-end}.lg\:gap-0{gap:0}.lg\:gap-3{gap:.75rem}.lg\:gap-y-20{row-gap:5rem}.lg\:opacity-100{opacity:1}.lg\:grayscale-\[50\%\]{--tw-grayscale:grayscale(50%)}.group:hover .lg\:group-hover\:grayscale-0,.lg\:grayscale-\[50\%\]{filter:var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)}.group:hover .lg\:group-hover\:grayscale-0{--tw-grayscale:grayscale(0)}}@media (min-width:1280px){.xl\:col-span-2{grid-column:span 2/span 2}.xl\:grid-cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}.xl\:opacity-100{opacity:1}}@media (min-width:1536px){.\32xl\:opacity-100{opacity:1}}</style><script data-domain="blakerain.com" defer src="https://pa.blakerain.com/js/script.js"></script><link href="/site-dc915905fe1d9f61_bg.wasm" rel="preload" type="application/wasm" as="fetch" crossorigin=""><link href="/site-dc915905fe1d9f61.js" rel="modulepreload"></head><body><!--<[]>--><!--<[]>--><!--<[]>--><!--<[]>--><!--<[]>--><!--<[]>--><!--<[]>--><!--<[]>--><div class="flex flex-col"><!--<[]>--><nav class="print:hidden bg-primary shadow-md dark:shadow-none text-neutral-200"><div class="container mx-auto flex flex-col md:flex-row px-4 sm:px-0"><div class="flex flex-row justify-between items-center my-4 md:my-0"><!--<[]>--><a href="/" class="block mr-4"><img src="/media/logo-text.png" width="154" height="28" alt="Blake Rain" class="block"></a><!--</[]>--><button type="button" class="md:hidden"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/lucide-icons/lucide - Licensed under ISC" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="12" x2="20" y2="12"></line><line x1="4" y1="6" x2="20" y2="6"></line><line x1="4" y1="18" x2="20" y2="18"></line></svg><!--</[]>--><span class="sr-only">Toggle Menu</span></button></div><div class="md:flex flex-col md:flex-row hidden"><!--<[]>--><a href="/blog" class="px-4 py-6 transition-colors hover:bg-primary-dark hover:text-neutral-50">Blog</a><!--</[]>--><!--<[]>--><a href="/about" class="px-4 py-6 transition-colors hover:bg-primary-dark hover:text-neutral-50">About</a><!--</[]>--></div><div class="hidden md:flex flex-row items-center gap-2 ml-auto"><a href="https://git.blakerain.com/" title="Gitea instance" target="_blank" rel="noreferrer" class="text-neutral-200/75 hover:text-neutral-200"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="width: 1.5em" fill="currentColor"><path d="M4.209 4.603c-.247 0-.525.02-.84.088-.333.07-1.28.283-2.054 1.027C-.403 7.25.035 9.685.089 10.052c.065.446.263 1.687 1.21 2.768 1.749 2.141 5.513 2.092 5.513 2.092s.462 1.103 1.168 2.119c.955 1.263 1.936 2.248 2.89 2.367 2.406 0 7.212-.004 7.212-.004s.458.004 1.08-.394c.535-.324 1.013-.893 1.013-.893s.492-.527 1.18-1.73c.21-.37.385-.729.538-1.068 0 0 2.107-4.471 2.107-8.823-.042-1.318-.367-1.55-.443-1.627-.156-.156-.366-.153-.366-.153s-4.475.252-6.792.306c-.508.011-1.012.023-1.512.027v4.474l-.634-.301c0-1.39-.004-4.17-.004-4.17-1.107.016-3.405-.084-3.405-.084s-5.399-.27-5.987-.324c-.187-.011-.401-.032-.648-.032zm.354 1.832h.111s.271 2.269.6 3.597C5.549 11.147 6.22 13 6.22 13s-.996-.119-1.641-.348c-.99-.324-1.409-.714-1.409-.714s-.73-.511-1.096-1.52C1.444 8.73 2.021 7.7 2.021 7.7s.32-.859 1.47-1.145c.395-.106.863-.12 1.072-.12zm8.33 2.554c.26.003.509.127.509.127l.868.422-.529 1.075a.686.686 0 0 0-.614.359.685.685 0 0 0 .072.756l-.939 1.924a.69.69 0 0 0-.66.527.687.687 0 0 0 .347.763.686.686 0 0 0 .867-.206.688.688 0 0 0-.069-.882l.916-1.874a.667.667 0 0 0 .237-.02.657.657 0 0 0 .271-.137 8.826 8.826 0 0 1 1.016.512.761.761 0 0 1 .286.282c.073.21-.073.569-.073.569-.087.29-.702 1.55-.702 1.55a.692.692 0 0 0-.676.477.681.681 0 1 0 1.157-.252c.073-.141.141-.282.214-.431.19-.397.515-1.16.515-1.16.035-.066.218-.394.103-.814-.095-.435-.48-.638-.48-.638-.467-.301-1.116-.58-1.116-.58s0-.156-.042-.27a.688.688 0 0 0-.148-.241l.516-1.062 2.89 1.401s.48.218.583.619c.073.282-.019.534-.069.657-.24.587-2.1 4.317-2.1 4.317s-.232.554-.748.588a1.065 1.065 0 0 1-.393-.045l-.202-.08-4.31-2.1s-.417-.218-.49-.596c-.083-.31.104-.691.104-.691l2.073-4.272s.183-.37.466-.497a.855.855 0 0 1 .35-.077z"></path></svg><!--</[]>--></a><a href="https://github.com/BlakeRain" title="GitHub" target="_blank" rel="noreferrer" class="text-neutral-200/75 hover:text-neutral-50"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/twbs/icons - Licensed under MIT" width="24" height="1.1em" fill="currentColor" viewBox="0 0 16 16"><path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg><!--</[]>--></a><a href="https://mastodonapp.uk/@BlakeRain" title="@BlakeRain@mastodonapp.uk" target="_blank" rel="me noreferrer" class="text-neutral-200/75 hover:text-neutral-50"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/twbs/icons - Licensed under MIT" width="24" height="1.1em" fill="currentColor" viewBox="0 0 16 16"><path d="M11.19 12.195c2.016-.24 3.77-1.475 3.99-2.603.348-1.778.32-4.339.32-4.339 0-3.47-2.286-4.488-2.286-4.488C12.062.238 10.083.017 8.027 0h-.05C5.92.017 3.942.238 2.79.765c0 0-2.285 1.017-2.285 4.488l-.002.662c-.004.64-.007 1.35.011 2.091.083 3.394.626 6.74 3.78 7.57 1.454.383 2.703.463 3.709.408 1.823-.1 2.847-.647 2.847-.647l-.06-1.317s-1.303.41-2.767.36c-1.45-.05-2.98-.156-3.215-1.928a3.614 3.614 0 0 1-.033-.496s1.424.346 3.228.428c1.103.05 2.137-.064 3.188-.189zm1.613-2.47H11.13v-4.08c0-.859-.364-1.295-1.091-1.295-.804 0-1.207.517-1.207 1.541v2.233H7.168V5.89c0-1.024-.403-1.541-1.207-1.541-.727 0-1.091.436-1.091 1.296v4.079H3.197V5.522c0-.859.22-1.541.66-2.046.456-.505 1.052-.764 1.793-.764.856 0 1.504.328 1.933.983L8 4.39l.417-.695c.429-.655 1.077-.983 1.934-.983.74 0 1.336.259 1.791.764.442.505.661 1.187.661 2.046v4.203z"></path></svg><!--</[]>--></a><a href="/feeds/feed.xml" title="RSS Feed" class="text-neutral-200/75 hover:text-neutral-50"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/lucide-icons/lucide - Licensed under ISC" width="24" height="1.1em" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg><!--</[]>--></a></div></div></nav><!--</[]>--><main><!--<[]>--><!--<[]>--><!--<[]>--><!--<[]>--><!--<[]>--><!--<[]>--><div></div><!--</[]>--><!--</[]>--><!--<[]>--><!--<[]>--><!--<[]>--><div></div><!--</[]>--><!--</[]>--><!--<[]>--><div></div><!--</[]>--><!--</[]>--><!--<[]>--><article><header class="hidden print:block container print:max-w-full mx-auto"><h1 class="text-3xl font-bold">Allocating Memory for DMA in Linux</h1><div class="flex uppercase text-sm flex-col md:flex-row items-center md:justify-between"><div class="flex flex-row gap-1"><div>11 Dec 2020</div><span class="text-gray-500">•</span><div>26 min read</div></div><div class="flex flex-row gap-1"><span class="text-sky-700 dark:text-sky-500">PCI</span><span class="text-gray-500">•</span><span class="text-sky-700 dark:text-sky-500">Linux</span><span class="text-gray-500">•</span><span class="text-sky-700 dark:text-sky-500">C++</span></div></div></header><header style="background-image: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url(/content/allocating-memory-for-dma-in-linux/cover.jpg)" class="print:hidden bg-[50%] bg-no-repeat bg-cover bg-fixed"><div class="container mx-auto flex flex-col items-center"><h1 class="mx-2 md:mx-0 mt-20 mb-10 text-5xl text-center font-bold text-white">Allocating Memory for DMA in Linux</h1><p class="font-sans text-lg text-center mx-5 md:mx-0 mb-20 lg:w-2/3 text-white">In this post we take a look at allocating memory on Linux using huge pages with the intention of
sharing that memory with PCIe devices that use DMA.</p><div class="pt-8 px-2 sm:px-16 bg-white dark:bg-zinc-900 sm:rounded-t w-full"><div class="flex uppercase text-sm flex-col md:flex-row items-center md:justify-between"><div class="flex flex-row gap-1"><div>11 Dec 2020</div><span class="text-gray-500">•</span><div>26 min read</div></div><div class="flex flex-row gap-1"><span class="text-sky-700 dark:text-sky-500">PCI</span><span class="text-gray-500">•</span><span class="text-sky-700 dark:text-sky-500">Linux</span><span class="text-gray-500">•</span><span class="text-sky-700 dark:text-sky-500">C++</span></div></div></div></div></header><div class="container mx-auto mt-6 lg:mt-12 mb-20 px-2 sm:px-16 print:px-0 print:max-w-full markdown numbered-headings"><!--<[]>--><p>I’ve recently had the pleasure of writing some user-space code that takes control of an Ethernet card – specifically the <a title="" href="https://ark.intel.com/content/www/us/en/ark/products/59062/intel-ethernet-server-adapter-i350-t2.html">Intel i350</a> and it’s kin. Part of the interface with the device requires sharing memory that contains packet descriptors and buffers. The device uses this memory for the communication of transmitted and received Ethernet packets.</p><!--</[]>--><!--<[]>--><p>When writing a user-space program that shares memory with a hardware device, we need to make sure that the memory is both accessible to hardware and respected by the operating system.</p><!--</[]>--><!--<[]>--><p>To begin to understand this requires us to be notionally aware of the manner in which devices will access the memory that we share with them, and how to ask the OS to respect the physical location of the memory.</p><!--</[]>--><!--<[]>--><h1>How Devices Can Access Memory</h1><!--</[]>--><!--<[]>--><p>These days, devices that are connected to a computer are typically connected via PCI Express (usually abbreviate to PCIe). Such devices will typically include support for accessing memory via DMA (Direct Memory Access).</p><!--</[]>--><!--<[]>--><p>Before the advent of DMA, when a device wanted to write data to memory it would have to interrupt the CPU. The CPU would read data from the PCI device into a register, and then copy the register into memory. This meant that the CPU was interrupted every time that a device wanted to read/write memory. This was less than ideal, especially as the number of devices requiring memory access increased.</p><!--</[]>--><!--<[]>--><p>DMA was introduced to allow devices to directly access system memory without interrupting the processor. In this model, an additional device (called a DMA engine) would handle the details of memory transfers. Later devices (often called Bus Masters) would integrate the DMA functionality locally, obviating the need for a discrete DMA engine.</p><!--</[]>--><!--<[]>--><p>In this more recent model of PCI, the <a title="" href="https://en.wikipedia.org/wiki/Northbridge_(computing)">North Bridge</a> would decode the address and recognize itself as the target of a PCI transaction, and during the data phase of the bus cycle, the data is transferred between the device and the North Bridge, which will in turn issue DRAM bus cycles to communicate with system memory.</p><!--</[]>--><!--<[]>--><blockquote><p>The term <em>bus mastering</em> is still used in PCI to enable a device to initiate DMA. It is often still necessary to enable bus mastering on many devices, and the command register in the PCI <a title="" href="https://en.wikipedia.org/wiki/PCI_configuration_space">configuration space</a> includes a flag to enable <a title="" href="https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/pci_regs.h#L43">bus mastering</a>.</p></blockquote><!--</[]>--><!--<[]>--><p>When programming a device connected via PCIe, you will typically be writing a base address for a region of memory that you have prepared for the device to access. However, this memory cannot be allocated in the usual way. This is due to the way memory addresses are translated by the <a title="" href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a> and the operating system – the memory that we traditionally allocate from the operating system is <em>virtual</em>.</p><!--</[]>--><!--<[]>--><h1 id="virt-and-phy-addresses" class="with-anchor group"><a href="#virt-and-phy-addresses" class="group-hover:block"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/lucide-icons/lucide - Licensed under ISC" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><!--</[]>--></a>Virtual and Physical Addresses</h1><!--</[]>--><!--<[]>--><p>Typical memory allocation, such as when we use <code>malloc</code> or <code>new</code>, ultimately uses memory the operating system has reserved for our process. The address that we receive from the OS will be an address in the <a title="" href="https://en.wikipedia.org/wiki/Virtual_memory">virtual memory</a> maintained by the OS.</p><!--</[]>--><!--<[]>--><p>This virtual address is used by our process when accessing memory, and the CPU will translate the virtual address to a physical memory address using the MMU.</p><!--</[]>--><!--<[]>--><p>Devices that use DMA to access memory will bypass the CPU when accessing memory, as the north bridge will translate certain PCI messages to DRAM cycles directly. As this process does not involve the MMU, no virtual address translation can take place.</p><!--</[]>--><!--<[]>--><p>This has the consequence that any memory that you allocate using <code>malloc</code> or <code>new</code> will result in a <em>virtual</em> memory address that, if passed as-is to a device, will result in that device attempting to access a completely different region of memory to the <em>physical</em> location(s) associated with the virtual address. As the CPU is no longer involved in the process, there is little to no protection against devices accessing arbitrary areas of system memory. This can have many unintended consequences – ranging from overwriting important areas of memory all the way to full-blown exfiltration of secrets. Which is nice.</p><!--</[]>--><!--<[]>--><p>It is important, therefore, that for any allocated memory we are able to obtain the corresponding physical memory address. However, this process is somewhat frustrated by the manner in which memory will be allocated by the operating system. There are a few things that need to be considered:</p><!--</[]>--><!--<[]>--><ol start="1"><li>Contiguous virtual memory is rarely physically contiguous (except perhaps when the machine boots or in small amounts).</li><li>The operating system is free to swap out pages of memory, such as when a process is considered idle or when the system is under memory pressure.</li></ol><!--</[]>--><!--<[]>--><p>In order to address these two primary concerns we need to look to an alternative means of memory allocation than the traditional <code>malloc</code> and <code>new</code>. Moreover, as we are likely to need more than a standard page’s worth of space (typically 4Kib), we need to allocate memory using larger pages of memory.</p><!--</[]>--><!--<[]>--><h1 id="physical-addresses" class="with-anchor group"><a href="#physical-addresses" class="group-hover:block"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/lucide-icons/lucide - Licensed under ISC" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><!--</[]>--></a>Establishing Physical Addresses</h1><!--</[]>--><!--<[]>--><p>We understand that a process operates on virtual memory, and that memory is arranged in pages. The question now arises as to how we can establish the corresponding physical address for any given virtual address.</p><!--</[]>--><!--<[]>--><p>An answer to this lies in the process page map. The page map is a table that provides a correspondence between a virtual page number and the physical address of that page, along with some flags that tell us information about the page’s residency. Each entry in the table is a 64-bit value, with bits 63 down through 55 providing the various flags, and bits 54 to 0 giving the page frame number (assuming the page is in RAM).</p><!--</[]>--><!--<[]>--><figure><img src="/content/allocating-memory-for-dma-in-linux/image-2-1.png" title="" alt="Layout of an entry in the page map"><figcaption>Layout of an entry in the page map</figcaption></figure><!--</[]>--><!--<[]>--><p>Note that bits 54 through 0 are only the physical page frame number if the page is currently in memory. Under other circumstances it can indicate such things as the swap type and offset. We can ascertain whether the page is actually in RAM by checking if bit 63 is set. If bit 63 is set then the bits 54 through 0 are the page frame number.</p><!--</[]>--><!--<[]>--><p>The page map is found under the <code>/proc</code> sub-directory for each process. A process is able to access this table by opening the <code>/proc/self/pagemap</code> file.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">int</span><span style="color:#c0c5ce"> fd = </span><span style="color:#8fa1b3">open</span><span style="color:#c0c5ce">("</span><span style="color:#a3be8c">/proc/self/pagemap</span><span style="color:#c0c5ce">", O_RDONLY);
</span><span style="color:#8fa1b3">assert</span><span style="color:#c0c5ce">(fd != -</span><span style="color:#d08770">1</span><span style="color:#c0c5ce">);
</span></pre><figcaption>Opening the process page map</figcaption></figure><!--</[]>--><!--<[]>--><p>Given a virtual address, we need to calculate the page in which the address resides. In order to do so we need to know the size of a page. Typically this will be 4Kib, but it is possible it may vary on different architectures. We can obtain the page size by using the <code>sysconf</code> function and querying the <code>_SC_PAGESIZE</code>. Given this page size we can then simply divide the virtual address (as a <code>uintptr_t</code>) by the page size to get the virtual page number.</p><!--</[]>--><!--<[]>--><p>Once we have the virtual page number we can look up our virtual page in the page map. Each entry in the page map is a 64-bit integer, so we need to multiply our virtual page number by eight to find the corresponding entry for the virtual address.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">int</span><span style="color:#c0c5ce"> res = </span><span style="color:#8fa1b3">lseek64</span><span style="color:#c0c5ce">(fd,
</span><span style="color:#c0c5ce">                  (uintptr_t)vaddr / page_size * sizeof(uintptr_t),
</span><span style="color:#c0c5ce">                  SEEK_SET);
</span><span style="color:#8fa1b3">assert</span><span style="color:#c0c5ce">(res != -</span><span style="color:#d08770">1</span><span style="color:#c0c5ce">);
</span></pre><figcaption>Seeking to an entry in the page map</figcaption></figure><!--</[]>--><!--<[]>--><p>With the file handle in <code>fd</code> pointing to the correct location in the page map, we can read the 64-bit integer at that address. We will read this into a <code>uintptr_t</code>, after which we can close the file.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">uintptr_t phy = </span><span style="color:#d08770">0</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">res = </span><span style="color:#8fa1b3">read</span><span style="color:#c0c5ce">(fd, &amp;phy, sizeof(uintptr_t));
</span><span style="color:#8fa1b3">assert</span><span style="color:#c0c5ce">(res == sizeof(uintptr_t));
</span><span style="color:#c0c5ce">
</span><span style="color:#8fa1b3">close</span><span style="color:#c0c5ce">(fd);
</span></pre><figcaption>Reading the entry from the page map</figcaption></figure><!--</[]>--><!--<[]>--><p>Now that we’ve read the entry from the page map we can first check to make sure that the address is actually present in RAM. Consulting our flags we see that bit 63 must be set for this to be the case.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#8fa1b3">assert</span><span style="color:#c0c5ce">((phy &amp; </span><span style="color:#8fa1b3">BIT</span><span style="color:#c0c5ce">(</span><span style="color:#d08770">63</span><span style="color:#c0c5ce">)) != </span><span style="color:#d08770">0</span><span style="color:#c0c5ce">);
</span></pre></figure><!--</[]>--><!--<[]>--><p>Now we can compute the physical address. The value given in the lower 55 bits of <code>phy</code> is the page frame number. The physical memory is divided into contiguous regions of the system page size, thus we can multiply the page frame number by the system page size to obtain the physical address.</p><!--</[]>--><!--<[]>--><figure class="code"><pre>physical_address = PFN * page_size
</pre></figure><!--</[]>--><!--<[]>--><p>To make our virtual to physical mapping complete, we should take into account the case where our virtual address is offset from the start of a page. Therefore we need to make sure to add that offset to the computed physical address. The offset from the start of the page to the virtual pointer can be obtained by taking the modulus with the system page size. We can then add this on to our computed physical address.</p><!--</[]>--><!--<[]>--><figure class="code"><pre>physical_address = PFN * page_size + (vaddr % page_size)
</pre></figure><!--</[]>--><!--<[]>--><p>Putting this all together we get a function <code>virtual_to_physical</code> that maps an address in the virtual address space of the process to a physical address.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">static </span><span style="color:#c0c5ce">uintptr_t </span><span style="color:#8fa1b3">virtual_to_physical</span><span style="color:#c0c5ce">(</span><span style="color:#b48ead">const void </span><span style="color:#c0c5ce">*</span><span style="color:#bf616a">vaddr</span><span style="color:#c0c5ce">) {
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">auto</span><span style="color:#c0c5ce"> page_size = </span><span style="color:#8fa1b3">sysconf</span><span style="color:#c0c5ce">(_SC_PAGESIZE);
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">int</span><span style="color:#c0c5ce">  fd        = </span><span style="color:#8fa1b3">open</span><span style="color:#c0c5ce">("</span><span style="color:#a3be8c">/proc/self/pagemap</span><span style="color:#c0c5ce">", O_RDONLY);
</span><span style="color:#c0c5ce">  </span><span style="color:#96b5b4">assert</span><span style="color:#c0c5ce">(fd != -</span><span style="color:#d08770">1</span><span style="color:#c0c5ce">);
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">int</span><span style="color:#c0c5ce"> res = </span><span style="color:#8fa1b3">::lseek64</span><span style="color:#c0c5ce">(fd, (uintptr_t)vaddr / page_size * sizeof(uintptr_t), SEEK_SET);
</span><span style="color:#c0c5ce">  </span><span style="color:#96b5b4">assert</span><span style="color:#c0c5ce">(res != -</span><span style="color:#d08770">1</span><span style="color:#c0c5ce">);
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  uintptr_t phy = </span><span style="color:#d08770">0</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">  res = </span><span style="color:#8fa1b3">read</span><span style="color:#c0c5ce">(fd, &amp;phy, sizeof(uintptr_t));
</span><span style="color:#c0c5ce">  </span><span style="color:#96b5b4">assert</span><span style="color:#c0c5ce">(res == sizeof(uintptr_t));
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#8fa1b3">close</span><span style="color:#c0c5ce">(fd);
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#96b5b4">assert</span><span style="color:#c0c5ce">((phy &amp; </span><span style="color:#8fa1b3">BIT</span><span style="color:#c0c5ce">(</span><span style="color:#d08770">63</span><span style="color:#c0c5ce">)) != </span><span style="color:#d08770">0</span><span style="color:#c0c5ce">);
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">return </span><span style="color:#c0c5ce">(phy &amp; </span><span style="color:#d08770">0x7fffffffffffffULL</span><span style="color:#c0c5ce">) * page_size
</span><span style="color:#c0c5ce">         + (uintptr_t)vaddr % page_size;
</span><span style="color:#c0c5ce">}
</span></pre><figcaption>Converting a virtual address to a physical address</figcaption></figure><!--</[]>--><!--<[]>--><p>We can now use the <code>virtual_to_physical</code> function to ascertain the physical address of some memory that we allocate from the operating system. This is the address that we pass on to our hardware.</p><!--</[]>--><!--<[]>--><h1 id="hugepages" class="with-anchor group"><a href="#hugepages" class="group-hover:block"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/lucide-icons/lucide - Licensed under ISC" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><!--</[]>--></a>Linux Huge Pages</h1><!--</[]>--><!--<[]>--><p>Now we know how to establish the physical address corresponding to a virtual address, the problem still remains that we need to obtain an address for <em>contiguous physical memory</em>, rather than merely the physical address of a single page. We are also still limited by the fact that the operating system may subject our memory to swapping and other operations.</p><!--</[]>--><!--<[]>--><p>The Linux operating system provides a facility to allocate memory in pages that are larger than 4Kib in size: huge pages. These huge pages are also treated somewhat differently than normal process memory.</p><!--</[]>--><!--<[]>--><p>Linux includes support for something called <em>hugetlbpage</em>, which provides access to larger page sizes supported by modern processors. Typically an x86 processor will support pages of 4Kib and 2Mib, and sometimes 1Gib.</p><!--</[]>--><!--<[]>--><p>Allocated huge pages are reserved by the Linux kernel in a huge page pool. These pages will be pre-allocated, and cannot be swapped out when the system is under memory pressure. The reservation of these huge pages depends on the availability of physically contiguous memory in the system. The kernel is typically instructed to arrange huge page reservation in two ways:</p><!--</[]>--><!--<[]>--><ol start="1"><li>Configured on boot by specifying the <code>hugepages=N</code> parameter in the kernel boot command line, or</li><li>Dynamically by writing to <code>/proc/sys/vm/nr_hugepages</code>, or</li><li>Dynamically by writing to the corresponding <code>nr_hugepages</code> file for the NUMA node.</li></ol><!--</[]>--><!--<[]>--><p>For example, the number of 2Mib huge pages reserved under NUMA node 0 is found in the file at the following location:</p><!--</[]>--><!--<[]>--><figure class="code"><pre>/sys/devices/system/node/node0/hugepages/hugepages-2048kB/nr_hugepages
</pre></figure><!--</[]>--><!--<[]>--><p>Writing to this file will dynamically change the number of huge pages allocated for the corresponding NUMA node. For example, to allocate 32 2Mib huge pages per NUMA node on a system with 8 NUMA nodes you could run the following shell script:</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#bf616a">NUMA_DIR</span><span style="color:#c0c5ce">="</span><span style="color:#a3be8c">/sys/devices/system/node</span><span style="color:#c0c5ce">"
</span><span style="color:#bf616a">HUGEPAGE_DIR</span><span style="color:#c0c5ce">="</span><span style="color:#a3be8c">hugepages/hugepages-2048kB</span><span style="color:#c0c5ce">"
</span><span style="color:#c0c5ce">
</span><span style="color:#b48ead">for</span><span style="color:#c0c5ce"> i </span><span style="color:#b48ead">in </span><span style="color:#c0c5ce">{0..7}; </span><span style="color:#b48ead">do
</span><span style="color:#c0c5ce">  </span><span style="color:#96b5b4">echo</span><span style="color:#c0c5ce"> 32 &gt; $</span><span style="color:#bf616a">NUMA_DIR</span><span style="color:#c0c5ce">/node$</span><span style="color:#bf616a">i</span><span style="color:#c0c5ce">/$</span><span style="color:#bf616a">HUGEPAGE_DIR</span><span style="color:#c0c5ce">/nr_hugepages
</span><span style="color:#b48ead">done
</span></pre><figcaption>Allocating 32 huge pages over eight NUMA nodes</figcaption></figure><!--</[]>--><!--<[]>--><p>Something to note is that the kernel will try and balance the huge page pool over all NUMA nodes. Moreover, if the reservation of physically contiguous memory under a subset of NUMA nodes is unsuccessful, the kernel may try and complete the reservation by allocating the extra pages on other nodes. This can result in some bottlenecks when you assume all your huge pages are resident on the same NUMA set.</p><!--</[]>--><!--<[]>--><p>Huge pages provide a rather nice solution to our problem of obtaining large contiguous regions of memory that are not going to be swapped out by the operating system.</p><!--</[]>--><!--<[]>--><h1 id="hugepage-availability" class="with-anchor group"><a href="#hugepage-availability" class="group-hover:block"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/lucide-icons/lucide - Licensed under ISC" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><!--</[]>--></a>Establishing Huge Page Availability</h1><!--</[]>--><!--<[]>--><p>The first step towards allocating huge pages is to establish what huge pages are available to us. To do so we’re going to query some files in the <code>/sys/kernel/mm/hugepages</code> directory. If any huge pages are configured, this directory will contain sub-directories for each huge page size:</p><!--</[]>--><!--<[]>--><figure class="code"><pre>$ ls /sys/kernel/mm/hugepages
hugepages-1048576kB hugepages-2048kB
</pre></figure><!--</[]>--><!--<[]>--><p>Each huge page directory contains a number of files that yield information about the number of reserved huge pages in the pool, the free count, and so on:</p><!--</[]>--><!--<[]>--><figure class="code"><pre>$ tree /sys/kernel/mm/hugepages
/sys/kernel/mm/hugepages/
├── hugepages-1048576kB
│   ├── free_hugepages
│   ├── nr_hugepages
│   ├── nr_hugepages_mempolicy
│   ├── nr_overcommit_hugepages
│   ├── resv_hugepages
│   └── surplus_hugepages
└── hugepages-2048kB
    ├── free_hugepages
    ├── nr_hugepages
    ├── nr_hugepages_mempolicy
    ├── nr_overcommit_hugepages
    ├── resv_hugepages
    └── surplus_hugepages
</pre><figcaption>Files and Directories under /sys/kernel/mm/hugepages</figcaption></figure><!--</[]>--><!--<[]>--><p>A quick summary of each of these files is given below, and a more precise description can be found in the <a title="" href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt">hugetlbpage.txt</a> documentation.</p><!--</[]>--><!--<[]>--><ul><li><code>free_hugepages</code> – The number of huge pages in the pool that are not yet allocated.</li><li><code>nr_hugepages</code> – The number of persistent huge pages in the pool. These are huge pages that, when freed, will be returned to the pool.</li><li><code>nr_hugepages_mempolicy</code> – Whether to allocate huge pages via the <code>/proc</code> or <code>/sys</code> interface.</li><li><code>nr_overcommit_hugepages</code> – The maximum number of surplus hugepages.</li><li><code>resv_hugepages</code> – The number of huge pages the OS has committed to reserve, but not yet completed allocation.</li><li><code>surplus_hugepages</code> – Number of surplus huge pages that are in the pool above that given in <code>nr_hugepages</code>, limited by <code>nr_overcommit_hugepages</code>.</li></ul><!--</[]>--><!--<[]>--><p>You can use these files to establish information such as whether an allocation will succeed based on the number of available huge pages given in <code>free_hugepages</code>. For the sake of simplicity, as we’re only really concerned with the process of allocating these huge pages, I’m going to ignore them in this post.</p><!--</[]>--><!--<[]>--><p>In order for our program to comprehend the available huge pages we’ll load some information from the <code>/sys/kernel/mm/hugepages</code> directory and encapsulate it in a <code>HugePageInfo</code> structure.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">namespace </span><span style="color:#c0c5ce">fs = std::experimental::file_system;
</span><span style="color:#c0c5ce">
</span><span style="color:#b48ead">struct </span><span style="color:#c0c5ce">HugePageInfo {
</span><span style="color:#c0c5ce">  std::size_t size; </span><span style="color:#65737e">// The size of the hugepage (in bytes)
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#8fa1b3">HugePageInfo</span><span style="color:#c0c5ce">(</span><span style="color:#b48ead">const</span><span style="color:#c0c5ce"> fs::directory_entry &amp;);
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Allocate a huge page in this pool
</span><span style="color:#c0c5ce">  HugePage::Ref </span><span style="color:#8fa1b3">allocate</span><span style="color:#c0c5ce">() </span><span style="color:#b48ead">const</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Load all the available huge page pools
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">static</span><span style="color:#c0c5ce"> std::vector&lt;HugePageInfo&gt; </span><span style="color:#8fa1b3">load</span><span style="color:#c0c5ce">();
</span><span style="color:#c0c5ce">};
</span></pre><figcaption>HugePageInfo Structure</figcaption></figure><!--</[]>--><!--<[]>--><p>The structure retains the size of the huge page in bytes along with the path to the mount point of the <code>hugetlbfs</code> into which we should create our files for allocation.</p><!--</[]>--><!--<[]>--><p>When we construct a <code>HugePageInfo</code> structure we pass in a <a title="" href="https://en.cppreference.com/w/cpp/experimental/fs/directory_entry"><code>directory_entry</code></a> that represents the sub-directory under <code>/sys/kernel/mm/hugepages</code>. This sub-directory will have a name that includes the size of the huge-pages that can be allocated within that huge page table. We’ll use a regular expression to extract the page size from the directory name before we parse it.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">static const</span><span style="color:#c0c5ce"> std::regex HUGEPAGE_RE{"</span><span style="color:#a3be8c">hugepages-([0-9]+[kKmMgG])[bB]</span><span style="color:#c0c5ce">"};
</span><span style="color:#c0c5ce">
</span><span style="color:#8fa1b3">HugePageInfo::HugePageInfo</span><span style="color:#c0c5ce">(</span><span style="color:#b48ead">const</span><span style="color:#c0c5ce"> fs::directory_entry &amp;</span><span style="color:#bf616a">entry</span><span style="color:#c0c5ce">) {
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Extract the size of the hugepage from the directory name
</span><span style="color:#c0c5ce">  std::smatch match;
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">if </span><span style="color:#c0c5ce">(</span><span style="color:#8fa1b3">std::regex_match</span><span style="color:#c0c5ce">(entry.</span><span style="color:#8fa1b3">path</span><span style="color:#c0c5ce">().</span><span style="color:#8fa1b3">filename</span><span style="color:#c0c5ce">(), match, HUGEPAGE_RE)) {
</span><span style="color:#c0c5ce">    size = </span><span style="color:#8fa1b3">parse_suffixed_size</span><span style="color:#c0c5ce">(match[</span><span style="color:#d08770">1</span><span style="color:#c0c5ce">].</span><span style="color:#8fa1b3">str</span><span style="color:#c0c5ce">());
</span><span style="color:#c0c5ce">  } </span><span style="color:#b48ead">else </span><span style="color:#c0c5ce">{
</span><span style="color:#c0c5ce">    </span><span style="color:#b48ead">throw </span><span style="color:#8fa1b3">std::runtime_error</span><span style="color:#c0c5ce">("</span><span style="color:#a3be8c">Unable to parse hugepage name</span><span style="color:#c0c5ce">");
</span><span style="color:#c0c5ce">  }
</span><span style="color:#c0c5ce">}
</span></pre><figcaption>HugePageInfo Constructor</figcaption></figure><!--</[]>--><!--<[]>--><p>To load all the available huge pages we can scan the <code>/sys/kernel/mm/hugepages</code> directory and construct a <code>HugePageInfo</code> instance for each sub-directory. This task is performed by the <code>HugePageInfo::load</code> method.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">static const</span><span style="color:#c0c5ce"> fs::path SYS_HUGEPAGE_DIR = "</span><span style="color:#a3be8c">/sys/kernel/mm/hugepages</span><span style="color:#c0c5ce">";
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">std::vector&lt;HugePageInfo&gt; </span><span style="color:#8fa1b3">HugePageInfo::load</span><span style="color:#c0c5ce">() {
</span><span style="color:#c0c5ce">  std::vector&lt;HugePageInfo&gt; huge_pages;
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">for </span><span style="color:#c0c5ce">(</span><span style="color:#b48ead">auto </span><span style="color:#c0c5ce">&amp;entry : </span><span style="color:#8fa1b3">fs::directory_iterator</span><span style="color:#c0c5ce">(SYS_HUGEPAGE_DIR)) {
</span><span style="color:#c0c5ce">    huge_pages.</span><span style="color:#8fa1b3">emplace_back</span><span style="color:#c0c5ce">(entry);
</span><span style="color:#c0c5ce">  }
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">return</span><span style="color:#c0c5ce"> huge_pages;
</span><span style="color:#c0c5ce">}
</span></pre><figcaption>Loading the available huge page information from /sys/kernel/mm/hugepages</figcaption></figure><!--</[]>--><!--<[]>--><h1 id="allocating" class="with-anchor group"><a href="#allocating" class="group-hover:block"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/lucide-icons/lucide - Licensed under ISC" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><!--</[]>--></a>Allocating a Huge Page</h1><!--</[]>--><!--<[]>--><p>Each huge page allocation is described by a <code>HugePage</code> structure. This structure encapsulates the virtual and physical address of an allocated huge page along with the size of the page in bytes.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">struct </span><span style="color:#c0c5ce">HugePage {
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">using</span><span style="color:#c0c5ce"> Ref = std::shared_ptr&lt;HugePage&gt;;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">void </span><span style="color:#c0c5ce">*      virt;
</span><span style="color:#c0c5ce">  uintptr_t   phy;
</span><span style="color:#c0c5ce">  std::size_t size;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#8fa1b3">HugePage</span><span style="color:#c0c5ce">(</span><span style="color:#b48ead">void </span><span style="color:#c0c5ce">*</span><span style="color:#bf616a">v</span><span style="color:#c0c5ce">, uintptr_t </span><span style="color:#bf616a">p</span><span style="color:#c0c5ce">, std::size_t </span><span style="color:#bf616a">sz</span><span style="color:#c0c5ce">)
</span><span style="color:#c0c5ce">    : </span><span style="color:#bf616a">virt</span><span style="color:#c0c5ce">(v), </span><span style="color:#bf616a">phy</span><span style="color:#c0c5ce">(p), </span><span style="color:#bf616a">size</span><span style="color:#c0c5ce">(sz) {
</span><span style="color:#c0c5ce">  }
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#8fa1b3">~HugePage</span><span style="color:#c0c5ce">();
</span><span style="color:#c0c5ce">};
</span></pre><figcaption>The HugePageAlloc structure</figcaption></figure><!--</[]>--><!--<[]>--><p>To allocate a huge page we want to use the <code>mmap</code> system call with the <code>MAP_HUGETLB</code> flag. If we did not use the <code>MAP_HUGEPAGE</code> flag then we would need to mount a <code>hugetlbfs</code> of the required size into a directory somewhere and create files within that file system. We would rather avoid this method, so we use <code>MAP_HUGETLB</code> instead.</p><!--</[]>--><!--<[]>--><p>As we are not backing this mapping with a file, we need to use the <code>MAP_ANONYMOUS</code> flag. A portable application making use of <code>MAP_ANONYMOUS</code> should set the file descriptor to -1 and pass zero as the offset.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">HugePage::Ref </span><span style="color:#8fa1b3">HugePageInfo::allocate</span><span style="color:#c0c5ce">() </span><span style="color:#b48ead">const </span><span style="color:#c0c5ce">{
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Map a hugepage into memory
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">void </span><span style="color:#c0c5ce">*vaddr = (</span><span style="color:#b48ead">void </span><span style="color:#c0c5ce">*)</span><span style="color:#8fa1b3">mmap</span><span style="color:#c0c5ce">(</span><span style="color:#d08770">NULL</span><span style="color:#c0c5ce">, size,
</span><span style="color:#c0c5ce">                             PROT_READ | PROT_WRITE,
</span><span style="color:#c0c5ce">                             MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB,
</span><span style="color:#c0c5ce">                             -</span><span style="color:#d08770">1</span><span style="color:#c0c5ce">, </span><span style="color:#d08770">0</span><span style="color:#c0c5ce">);
</span><span style="color:#c0c5ce">  </span><span style="color:#96b5b4">assert</span><span style="color:#c0c5ce">(vaddr != MAP_FAILED);
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">return </span><span style="color:#c0c5ce">std::</span><span style="color:#8fa1b3">make_shared</span><span style="color:#c0c5ce">&lt;HugePage&gt;(vaddr, </span><span style="color:#8fa1b3">virtual_to_physical</span><span style="color:#c0c5ce">(vaddr), size);
</span><span style="color:#c0c5ce">}
</span></pre><figcaption>Allocating a huge page and mapping it into process memory</figcaption></figure><!--</[]>--><!--<[]>--><p>The value that we return from <code>allocate</code> constructs a <code>HugePage</code> with the virtual address that we received from <code>mmap</code>, the equivalent physical address as calculated by our <code>virtual_to_physical</code> function and the size of the huge page.</p><!--</[]>--><!--<[]>--><h1 id="deallocating" class="with-anchor group"><a href="#deallocating" class="group-hover:block"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/lucide-icons/lucide - Licensed under ISC" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><!--</[]>--></a>Deallocating a Hugepage</h1><!--</[]>--><!--<[]>--><p>Once we no longer wish to retain a huge page we need to release it back into the huge page pool maintained by the operating system.</p><!--</[]>--><!--<[]>--><p>The <code>HugePage</code> destructor will use the <code>munmap</code> syscall to un-map the huge page from the process.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#8fa1b3">HugePage::~HugePage</span><span style="color:#c0c5ce">() {
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">int</span><span style="color:#c0c5ce"> rc = </span><span style="color:#8fa1b3">munmap</span><span style="color:#c0c5ce">(virt, size);
</span><span style="color:#c0c5ce">  </span><span style="color:#96b5b4">assert</span><span style="color:#c0c5ce">(rc != -</span><span style="color:#d08770">1</span><span style="color:#c0c5ce">);
</span><span style="color:#c0c5ce">}
</span></pre><figcaption>Releasing a HugePage back to the OS</figcaption></figure><!--</[]>--><!--<[]>--><h1 id="dividing-into-buffers" class="with-anchor group"><a href="#dividing-into-buffers" class="group-hover:block"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/lucide-icons/lucide - Licensed under ISC" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><!--</[]>--></a>Dividing Up a Hugepage into Buffers</h1><!--</[]>--><!--<[]>--><p><strong>Note:</strong> <em>If you only wanted to know about the allocation of huge pages then you can skip to the <a title="" href="#conclusion">conclusion</a>.</em></p><!--</[]>--><!--<[]>--><p>When writing the interface with the Ethernet card, I needed to be able to ensure that each huge page was carved up into a number of fixed size buffers. Moreover, these buffers had specific alignment considerations that could vary by device. To facilitate this, I laid out all the buffers in a huge page as follows:</p><!--</[]>--><!--<[]>--><figure class="code"><pre>                                A  ◀─╴size╶─▶  B  ◀─╴size╶─▶       ◀─╴size╶─▶
┌─────┬───┬───┬─────┬───┬─────┬───┬──────────┬───┬──────────┬─────┬──────────┐
│  C  │ H │ H │  …  │ H │  …  │▒▒▒│ Buffer 0 │░░░│ Buffer 1 │  …  │ Buffer n │
└─────┴───┴───┴─────┴───┴─────┴───┴──────────┴───┴──────────┴─────┴──────────┘
        │   │         │            ▲              ▲                ▲
        └───┼─────────┼────────────┘              │                │
            └─────────┼───────────────────────────┘                │
                      └────────────────────────────────────────────┘
</pre></figure><!--</[]>--><!--<[]>--><p>At the start of the huge page, denoted by the letter <code>C</code>, is a small “chunk” header that describes the contents of the huge page. Immediately after the chunk header are a series of buffer headers, denoted by the letter <code>H</code>. These headers contain information about each buffer.</p><!--</[]>--><!--<[]>--><p>There are two kinds of padding in this diagram:</p><!--</[]>--><!--<[]>--><ol start="1"><li>The first kind of padding, denoted by the letter <code>A</code>, is the padding between the end of the buffer headers and the first buffer in the page. This ensures the first buffer is positioned at the required alignment.</li><li>The second kind of padding, denoted by the letter <code>B</code>, is the inter-buffer padding. This padding ensures that each subsequent buffer is aligned as required.</li></ol><!--</[]>--><!--<[]>--><p>Each huge page starts with a <code>Chunk</code> structure describing the buffers that are contained in the page. This structure retains the <code>HugePage::Ref</code> that we receive from the <code>HugePageInfo::allocate()</code> function, along with the size of the buffers and a pointer to the first buffer header. The <code>Chunk</code> structure is padded to a multiple of 64 bytes to ease alignment.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">struct </span><span style="color:#c0c5ce">Chunk {
</span><span style="color:#c0c5ce">  HugePage::Ref dma;
</span><span style="color:#c0c5ce">  std::size_t   buf_size;
</span><span style="color:#c0c5ce">  Buffer *      first_buffer;
</span><span style="color:#c0c5ce">  Chunk *       next;
</span><span style="color:#c0c5ce">  uint32_t      padding[</span><span style="color:#d08770">2</span><span style="color:#c0c5ce">];
</span><span style="color:#c0c5ce">};
</span><span style="color:#c0c5ce">
</span><span style="color:#65737e">// Make sure our chunk header size is a multiple of 64 bytes
</span><span style="color:#c0c5ce">static_assert(sizeof(Chunk) % </span><span style="color:#d08770">64 </span><span style="color:#c0c5ce">== </span><span style="color:#d08770">0</span><span style="color:#c0c5ce">);
</span></pre><figcaption>The Chunk header at the start of a huge page</figcaption></figure><!--</[]>--><!--<[]>--><p>The <code>Buffer</code> structure describes the buffer header, and contains various information about the contents of the buffer. Again, this header is padded to a multiple of 64 bytes.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">struct </span><span style="color:#c0c5ce">Buffer {
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">void       </span><span style="color:#c0c5ce">*address;   </span><span style="color:#65737e">// Virtual address of the buffer data
</span><span style="color:#c0c5ce">  uint64_t    phy;       </span><span style="color:#65737e">// Physical address of the buffer data
</span><span style="color:#c0c5ce">  std::size_t size;      </span><span style="color:#65737e">// Size of the buffer
</span><span style="color:#c0c5ce">  Buffer *    next;      </span><span style="color:#65737e">// Next buffer in list (used for free list)
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Other data fields such as packet length, RSS hash and so on
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// can be added here, so long as 'padding' is adjusted accordingly.
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  uint32_t    padding[</span><span style="color:#d08770">8</span><span style="color:#c0c5ce">];
</span><span style="color:#c0c5ce">};
</span><span style="color:#c0c5ce">
</span><span style="color:#65737e">// Make sure the buffer header is a multiple of 64 bytes
</span><span style="color:#c0c5ce">static_assert(sizeof(Buffer) % </span><span style="color:#d08770">64 </span><span style="color:#c0c5ce">== </span><span style="color:#d08770">0</span><span style="color:#c0c5ce">);
</span></pre><figcaption>The Buffer structure describing a buffer header</figcaption></figure><!--</[]>--><!--<[]>--><p>In order to divide up a huge page we will need to populate the <code>Chunk</code> header at the start of the page, followed by the <code>Buffer</code> headers. This means we need to know:</p><!--</[]>--><!--<[]>--><ol start="1"><li>The offset to the first buffer in the chunk,</li><li>The amount of slop (spilled space) between the chunk header and the first buffer,</li><li>The amount of buffer slop, being the interstitial padding between each buffer to maintain alignment,</li><li>The number of buffers that we can fit into the huge page.</li></ol><!--</[]>--><!--<[]>--><p>To calculate this we use a structure called <code>ChunkLayout</code> which takes the parameters for our huge page and buffers and computes the best alignment and packing of the data.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">struct </span><span style="color:#c0c5ce">Layout {
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Our arguments/input variables
</span><span style="color:#c0c5ce">  std::size_t buffer_size;
</span><span style="color:#c0c5ce">  std::size_t alignment;
</span><span style="color:#c0c5ce">  std::size_t nbuffers;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Computed layout information
</span><span style="color:#c0c5ce">  uint64_t chunk_header_size{</span><span style="color:#d08770">0</span><span style="color:#c0c5ce">};
</span><span style="color:#c0c5ce">  uint64_t buffer0_offset{</span><span style="color:#d08770">0</span><span style="color:#c0c5ce">};
</span><span style="color:#c0c5ce">  uint64_t chunk_slop{</span><span style="color:#d08770">0</span><span style="color:#c0c5ce">};
</span><span style="color:#c0c5ce">  uint64_t buffer_slop{</span><span style="color:#d08770">0</span><span style="color:#c0c5ce">};
</span><span style="color:#c0c5ce">  uint64_t chunk_space{</span><span style="color:#d08770">0</span><span style="color:#c0c5ce">};
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#8fa1b3">Layout</span><span style="color:#c0c5ce">(std::size_t </span><span style="color:#bf616a">size</span><span style="color:#c0c5ce">,
</span><span style="color:#c0c5ce">         std::size_t </span><span style="color:#bf616a">align</span><span style="color:#c0c5ce">,
</span><span style="color:#c0c5ce">         std::size_t </span><span style="color:#bf616a">page_size</span><span style="color:#c0c5ce">) {
</span><span style="color:#c0c5ce">    buffer_size = size;
</span><span style="color:#c0c5ce">    alignment   = align;
</span><span style="color:#c0c5ce">    nbuffers    = </span><span style="color:#d08770">1</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">    </span><span style="color:#8fa1b3">optimize</span><span style="color:#c0c5ce">(page_size);
</span><span style="color:#c0c5ce">  }
</span><span style="color:#c0c5ce">
</span><span style="color:#b48ead">private</span><span style="color:#c0c5ce">:
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Compute the layout information for a given number of buffers
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">void </span><span style="color:#8fa1b3">compute</span><span style="color:#c0c5ce">(std::size_t </span><span style="color:#bf616a">n</span><span style="color:#c0c5ce">);
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Try and find a "best fit" buffer count
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">void </span><span style="color:#8fa1b3">optimize</span><span style="color:#c0c5ce">(std::size_t </span><span style="color:#bf616a">page_size</span><span style="color:#c0c5ce">);
</span><span style="color:#c0c5ce">};
</span></pre><figcaption>The Layout structure, used to compute our buffer layout</figcaption></figure><!--</[]>--><!--<[]>--><p>To compute the layout, we first need to ascertain the chunk header size, which we can do by adding the size of the <code>Chunk</code> structure to the size of the <code>Buffer</code> structure, multiplied by the number of buffers in the page.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">void </span><span style="color:#8fa1b3">Layout::compute</span><span style="color:#c0c5ce">(std::size_t </span><span style="color:#bf616a">n</span><span style="color:#c0c5ce">) {
</span><span style="color:#c0c5ce">  nbuffers = n;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Calculate the chunk header size (C + n * H)
</span><span style="color:#c0c5ce">  chunk_header_size = sizeof(Chunk) + sizeof(Buffer) * n;
</span></pre></figure><!--</[]>--><!--<[]>--><p>Next we want to calculate the offset from the end of the chunk headers to the first buffer. This uses an <code>align_to</code> template that simply rounds up a value until it’s a multiple of an alignment. We round up the size of the combined chunk header until it meets the requested buffer alignment, giving us the offset into the huge page of the first buffer.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">  buffer0_offset = align_to&lt;uint64_t&gt;(chunk_header_size, alignment);
</span></pre></figure><!--</[]>--><!--<[]>--><p>Now we need to know the amount of space between the first buffer and the end of the chunk header, which we can easily obtain by just subtracting the chunk header size from the offset of the first buffer.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">  chunk_slop = buffer0_offset - chunk_header_size;
</span></pre></figure><!--</[]>--><!--<[]>--><p>Now we need to work out the amount of interstitial space between each buffer. This is relevant, as there may be cases where the size of a buffer may not adhere to it’s own address alignment. The interstitial buffer space is simply the modulus of the buffer size and the requested buffer alignment.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">  buffer_slop = buffer_size % alignment;
</span></pre></figure><!--</[]>--><!--<[]>--><p>Finally we can calculate the amount of space that we use for this chunk. This is the total space, including:</p><!--</[]>--><!--<[]>--><ol start="1"><li>The size of the combined chunk header (made of one <code>Chunk</code> structure and one or more <code>Buffer</code> structures),</li><li>The slop before the first buffer,</li><li>The slop between the buffers, and</li><li>The buffer data itself.</li></ol><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Start off with the chunk header and slop.
</span><span style="color:#c0c5ce">  chunk_space = chunk_header_size + chunk_slop;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Add on the buffer data, where 'n' is the number of buffers.
</span><span style="color:#c0c5ce">  chunk_space += n * buffer_size;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Now accommodate the interstital slop. Bear in mind
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// that there is N-1 interstitials for N buffers.
</span><span style="color:#c0c5ce">  chunk_space += (n - </span><span style="color:#d08770">1</span><span style="color:#c0c5ce">) * buffer_slop;
</span><span style="background-color:#bf616a;color:#2b303b">}</span><span style="color:#c0c5ce">
</span></pre></figure><!--</[]>--><!--<[]>--><p>Now we’ve calculated the amount of space we’ll use for a given buffer size, alignment and number of buffers. We can move on to optimizing the number of buffers to make full use of a huge page.</p><!--</[]>--><!--<[]>--><p>To optimize the number of buffers we want to add buffers to the layout, until we get to an ideal configuration. We’ll know when we’ve reached saturation when the amount of space remaining exceeds the size of a huge page.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">void </span><span style="color:#8fa1b3">Layout::optimize</span><span style="color:#c0c5ce">(std::size_t </span><span style="color:#bf616a">page_size</span><span style="color:#c0c5ce">) {
</span><span style="color:#c0c5ce">  std::size_t current_nbuffers = nbuffers;
</span><span style="color:#c0c5ce">  std::size_t last_nbuffers    = current_nbuffers;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">for </span><span style="color:#c0c5ce">(;;) {
</span></pre></figure><!--</[]>--><!--<[]>--><p>The first thing we want to do is perform our layout calculation for the current number of buffers that we are testing:</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">    </span><span style="color:#65737e">// Compute the sizes of the chunk layout for the number of
</span><span style="color:#c0c5ce">    </span><span style="color:#65737e">// buffers in 'current_nbuffers'.
</span><span style="color:#c0c5ce">    </span><span style="color:#8fa1b3">compute</span><span style="color:#c0c5ce">(current_nbuffers);
</span></pre></figure><!--</[]>--><!--<[]>--><p>Now we’ve calculated the size of the required space for <code>current_nbuffers</code> buffers, which is given in the <code>chunk_space</code> field. We check to see if this exceeds the size of a page. If it does, we terminate our search. If it does not, we increment the number of buffers and continue.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">    </span><span style="color:#b48ead">if </span><span style="color:#c0c5ce">(chunk_space &gt; page_size) {
</span><span style="color:#c0c5ce">      </span><span style="color:#b48ead">break</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">    }
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">    last_nbuffers = current_nbuffers;
</span><span style="color:#c0c5ce">    ++current_nbuffers;
</span><span style="color:#c0c5ce">  </span><span style="background-color:#bf616a;color:#2b303b">}</span><span style="color:#c0c5ce">
</span></pre></figure><!--</[]>--><!--<[]>--><p>After the for loop we are going to be in one of two conditions:</p><!--</[]>--><!--<[]>--><ol start="1"><li>The <code>last_nbuffers</code> variable contains the last number of buffers that fit within the given page size, or</li><li>We couldn’t even fit one buffer in.</li></ol><!--</[]>--><!--<[]>--><p>To finish off the optimisation of the layout we will first run a calculation of the layout for the <code>last_nbuffers</code> value, and then check to make sure we actually fit within the page. If we did not fit, then our page is too small for the required buffer size and alignment.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">  </span><span style="color:#8fa1b3">compute</span><span style="color:#c0c5ce">(last_nbuffers);
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">if </span><span style="color:#c0c5ce">(chunk_space &gt; page_size) {
</span><span style="color:#c0c5ce">    </span><span style="color:#b48ead">throw </span><span style="color:#8fa1b3">std::runtime_error</span><span style="color:#c0c5ce">("</span><span style="color:#a3be8c">Page cannot accommodate buffers</span><span style="color:#c0c5ce">");
</span><span style="color:#c0c5ce">  }
</span><span style="background-color:#bf616a;color:#2b303b">}</span><span style="color:#c0c5ce">
</span></pre></figure><!--</[]>--><!--<[]>--><p>Now that we are able to calculate the layout of a series of identically sized buffers, we can build a class <code>DMAPool</code> that will set up and manage all the buffers for us. This class has a couple of goals:</p><!--</[]>--><!--<[]>--><ol start="1"><li>Given a <code>HugePageInfo</code>, required buffer size and alignment, compute the layout using the <code>Layout</code> structure.</li><li>Provide an interface for allocating and deallocating buffers from the <code>DMAPool</code>, where the pool allocates a new <code>HugePageAlloc</code> when the available buffers are exhausted.</li></ol><!--</[]>--><!--<[]>--><p>The <code>DMAPool</code> class keeps track of a list of free buffers by linking together the <code>Buffer::next</code> fields into a single linked list. This forms a free list from which buffers can be allocated. When we exhaust this list, the <code>DMAPool</code> will request a new <code>HugePageAlloc</code> from it’s <code>HugePageInfo</code>, set up all the <code>Buffer</code> headers and chain them onto the free list.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">class </span><span style="color:#ebcb8b">DMAPool </span><span style="color:#eff1f5">{
</span><span style="color:#eff1f5">  </span><span style="color:#b48ead">const</span><span style="color:#eff1f5"> HugePageInfo </span><span style="color:#c0c5ce">*</span><span style="color:#eff1f5">_huge_page;
</span><span style="color:#eff1f5">  Layout              _layout;
</span><span style="color:#eff1f5">  Chunk </span><span style="color:#c0c5ce">*</span><span style="color:#eff1f5">             _first_chunk{</span><span style="color:#d08770">nullptr</span><span style="color:#eff1f5">};
</span><span style="color:#eff1f5">  Buffer </span><span style="color:#c0c5ce">*</span><span style="color:#eff1f5">            _free_list{</span><span style="color:#d08770">nullptr</span><span style="color:#eff1f5">};
</span><span style="color:#eff1f5">
</span><span style="color:#eff1f5">  </span><span style="color:#b48ead">void </span><span style="color:#8fa1b3">new_chunk</span><span style="color:#eff1f5">();
</span><span style="color:#eff1f5">
</span><span style="color:#b48ead">public</span><span style="color:#eff1f5">:
</span><span style="color:#eff1f5">  </span><span style="color:#8fa1b3">DMAPool</span><span style="color:#eff1f5">(</span><span style="color:#b48ead">const</span><span style="color:#eff1f5"> HugePageInfo </span><span style="color:#c0c5ce">*</span><span style="color:#bf616a">hp</span><span style="color:#eff1f5">,
</span><span style="color:#eff1f5">          std::size_t </span><span style="color:#bf616a">buffer_size</span><span style="color:#eff1f5">,
</span><span style="color:#eff1f5">          std::size_t </span><span style="color:#bf616a">alignment</span><span style="color:#eff1f5">)
</span><span style="color:#eff1f5">    : </span><span style="color:#bf616a">_huge_page</span><span style="color:#eff1f5">(hp), </span><span style="color:#bf616a">_layout</span><span style="color:#eff1f5">(buffer_size, alignment, hp-&gt;</span><span style="color:#bf616a">size</span><span style="color:#eff1f5">) {
</span><span style="color:#eff1f5">  }
</span><span style="color:#eff1f5">  </span><span style="color:#8fa1b3">~DMAPool</span><span style="color:#eff1f5">();
</span><span style="color:#eff1f5">
</span><span style="color:#eff1f5">  Buffer </span><span style="color:#c0c5ce">*</span><span style="color:#8fa1b3">allocate</span><span style="color:#eff1f5">();
</span><span style="color:#eff1f5">  </span><span style="color:#b48ead">void    </span><span style="color:#8fa1b3">free</span><span style="color:#eff1f5">(Buffer </span><span style="color:#c0c5ce">*</span><span style="color:#eff1f5">);
</span><span style="color:#eff1f5">}</span><span style="color:#c0c5ce">;
</span></pre><figcaption>The DMAPool class</figcaption></figure><!--</[]>--><!--<[]>--><p>The first function we should consider is the <code>DMAPool::new_chunk</code> method. This method will allocate a new <code>HugePageAlloc</code> from the <code>HugePageInfo</code> and carve it up into the required number of buffers.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">void </span><span style="color:#8fa1b3">DMAPool::new_chunk</span><span style="color:#c0c5ce">() {
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Allocate a huge page
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">auto</span><span style="color:#c0c5ce"> page = _huge_page-&gt;</span><span style="color:#8fa1b3">allocate</span><span style="color:#c0c5ce">();
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// We need to move around by bytes from the start of the virtual
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// address of the huge page. We'll create a 'start' pointer for
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// this process.
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  uint8_t *start = (uint8_t *)page.</span><span style="color:#bf616a">virt</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Our 'Chunk' starts at the virtual address of the page
</span><span style="color:#c0c5ce">  Chunk *chunk = (Chunk *)start;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Populate some of the fields of the chunk header
</span><span style="color:#c0c5ce">  chunk-&gt;</span><span style="color:#bf616a">dma      </span><span style="color:#c0c5ce">= page;
</span><span style="color:#c0c5ce">  chunk-&gt;</span><span style="color:#bf616a">buf_size </span><span style="color:#c0c5ce">= _layout.</span><span style="color:#bf616a">buffer_size</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Get a pointer to the first buffer header in the page
</span><span style="color:#c0c5ce">  Buffer *buffer = (Buffer *)(start + sizeof(Chunk));
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Set this as the first buffer header in the chunk
</span><span style="color:#c0c5ce">  chunk-&gt;</span><span style="color:#bf616a">first_buffer </span><span style="color:#c0c5ce">= buffer;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#65737e">// Get a pointer to the first buffer data in the page
</span><span style="color:#c0c5ce">  uint8_t *buffer_data = start + _layout.</span><span style="color:#bf616a">buffer0_offset</span><span style="color:#c0c5ce">;
</span></pre></figure><!--</[]>--><!--<[]>--><p>Now we need to iterate through the <code>Buffer</code> headers in the chunk and fill in the information. As we go we increment the <code>Buffer</code> pointer as all the buffer headers are contiguous. We increment the <code>buffer_data</code> field by the buffer size, plus the interstitial space from our layout. This preserves the alignment of the buffer data.</p><!--</[]>--><!--<[]>--><p>After we have populated each <code>Buffer</code> header structure, we chain it onto the front of the free list maintained by the <code>DMAPool</code> class.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">  </span><span style="color:#b48ead">for </span><span style="color:#c0c5ce">(std::size_t i = </span><span style="color:#d08770">0</span><span style="color:#c0c5ce">; i &lt; _layout.</span><span style="color:#bf616a">nbuffers</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">       ++i, ++buffer,
</span><span style="color:#c0c5ce">       buffer_data += (_layout.</span><span style="color:#bf616a">buffer_size </span><span style="color:#c0c5ce">+ _layout.</span><span style="color:#bf616a">buffer_slop</span><span style="color:#c0c5ce">)) {
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">    </span><span style="color:#65737e">// Set the fields of the buffer header
</span><span style="color:#c0c5ce">    buffer-&gt;</span><span style="color:#bf616a">address </span><span style="color:#c0c5ce">= buffer_data;
</span><span style="color:#c0c5ce">    buffer-&gt;</span><span style="color:#bf616a">phy     </span><span style="color:#c0c5ce">= page.</span><span style="color:#bf616a">phy </span><span style="color:#c0c5ce">+ (buffer_data - start);
</span><span style="color:#c0c5ce">    buffer-&gt;</span><span style="color:#bf616a">size    </span><span style="color:#c0c5ce">= _layout.</span><span style="color:#bf616a">buffer_size</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">    </span><span style="color:#65737e">// Chain this buffer onto the free list
</span><span style="color:#c0c5ce">    buffer-&gt;</span><span style="color:#bf616a">next </span><span style="color:#c0c5ce">= _free_list;
</span><span style="color:#c0c5ce">    _free_list   = buffer;
</span><span style="color:#c0c5ce">  }
</span></pre></figure><!--</[]>--><!--<[]>--><p>Now that we’ve allocated a new huge page and populated all the buffer headers we can chain the chunk onto our chunk list.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">  chunk-&gt;</span><span style="color:#bf616a">next  </span><span style="color:#c0c5ce">= _first_chunk;
</span><span style="color:#c0c5ce">  _first_chunk = chunk;
</span><span style="background-color:#bf616a;color:#2b303b">}</span><span style="color:#c0c5ce">
</span></pre></figure><!--</[]>--><!--<[]>--><p>An important point to note is that we’re computing the physical address of a buffer by adding the offset of the virtual address of the buffer data from the start of the page to the physical address of the page. This is fine when we’re only allocating a single huge page at a time. If this were not the case, we’d need to ensure that we’re calculating the physical address using our <code>virtual_to_physical</code> function defined earlier. This is because, whilst a huge page is physically contiguous, an allocation of two or more huge pages may not be physically contiguous. Put another way, an allocation of two huge pages may not yield two huge pages that are placed physically next to each other.</p><!--</[]>--><!--<[]>--><p>When we want to allocate a <code>Buffer</code> from the <code>DMAPool</code> we call the <code>DMAPool::allocate</code> method. This will first try and return a <code>Buffer</code> from the head of the buffer free list. If the free list is empty, it will call the <code>DMAPool::new_chunk</code> method to create a new <code>Chunk</code>. This method will also chain all the buffer headers onto the free list. The <code>allocate</code> method may then return a newly allocated buffer.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#c0c5ce">Buffer *</span><span style="color:#8fa1b3">DMAPool::allocate</span><span style="color:#c0c5ce">() {
</span><span style="color:#c0c5ce">  Buffer *buffer = _free_list;
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">if </span><span style="color:#c0c5ce">(!buffer) {
</span><span style="color:#c0c5ce">    </span><span style="color:#8fa1b3">new_chunk</span><span style="color:#c0c5ce">();
</span><span style="color:#c0c5ce">    buffer = _free_list;
</span><span style="color:#c0c5ce">  }
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  _free_list   = buffer-&gt;</span><span style="color:#bf616a">next</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">  buffer-&gt;</span><span style="color:#bf616a">next </span><span style="color:#c0c5ce">= </span><span style="color:#d08770">nullptr</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">return</span><span style="color:#c0c5ce"> buffer;
</span><span style="color:#c0c5ce">}
</span></pre><figcaption>Allocating a Buffer from a DMAPool</figcaption></figure><!--</[]>--><!--<[]>--><p>When we want to free a <code>Buffer</code> we simply append it to the free list in the <code>DMAPool</code>.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#b48ead">void </span><span style="color:#8fa1b3">DMAPool::free</span><span style="color:#c0c5ce">(Buffer *</span><span style="color:#bf616a">buffer</span><span style="color:#c0c5ce">) {
</span><span style="color:#c0c5ce">  buffer-&gt;</span><span style="color:#bf616a">next </span><span style="color:#c0c5ce">= _free_list;
</span><span style="color:#c0c5ce">  _free_list   = buffer;
</span><span style="color:#c0c5ce">}
</span></pre><figcaption>Freeing a Buffer back to the DMAPool</figcaption></figure><!--</[]>--><!--<[]>--><p>Finally, when we are done with a <code>DMAPool</code> it’s destructor will be called. This destructor needs to free all the <code>HugePageAlloc</code> information in each <code>Chunk</code>.</p><!--</[]>--><!--<[]>--><figure class="code"><pre style="background-color: #2b303b;"><span style="color:#8fa1b3">DMAPool::~DMAPool</span><span style="color:#c0c5ce">() {
</span><span style="color:#c0c5ce">  Chunk *chunk = _first_chunk;
</span><span style="color:#c0c5ce">  Chunk *next  = </span><span style="color:#d08770">nullptr</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">
</span><span style="color:#c0c5ce">  </span><span style="color:#b48ead">while </span><span style="color:#c0c5ce">(chunk) {
</span><span style="color:#c0c5ce">    next = chunk-&gt;</span><span style="color:#bf616a">next</span><span style="color:#c0c5ce">;
</span><span style="color:#c0c5ce">    chunk-&gt;</span><span style="color:#bf616a">dma</span><span style="color:#c0c5ce">.</span><span style="color:#8fa1b3">free</span><span style="color:#c0c5ce">();
</span><span style="color:#c0c5ce">    chunk = next;
</span><span style="color:#c0c5ce">  }
</span><span style="color:#c0c5ce">}
</span></pre><figcaption>DMAPool destructor</figcaption></figure><!--</[]>--><!--<[]>--><p>With the <code>DMAPool</code> implemented we can begin to portion out buffers of the required size and alignment to hardware. Hardware will require the physical address of each <code>Buffer</code> we allocate from the pool, which is available in the <code>Buffer::phy</code> field. Our process is also able to access this memory via the pointer in the <code>Buffer::address</code> field.</p><!--</[]>--><!--<[]>--><h1 id="conclusion" class="with-anchor group"><a href="#conclusion" class="group-hover:block"><!--<[]>--><svg xmlns="http://www.w3.org/2000/svg" data-license="From https://github.com/lucide-icons/lucide - Licensed under ISC" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg><!--</[]>--></a>Conclusion</h1><!--</[]>--><!--<[]>--><p>Preparing memory for use with DMA may seem a bit more complex than necessary. As developers we’re often shielded from the details of memory management by useful abstractions such as those provided by <code>malloc</code> and <code>new</code>. This can mean that we are rarely exposed to the manner in which memory is managed by the operating system and our programs.</p><!--</[]>--><!--<[]>--><p>I hope that this post may be of some use to those of you that need to communicate memory with devices connected to the PCI bus. You can find the complete listing as a GitHub gist:</p><!--</[]>--><!--<[]>--><figure class="w-full text-base"><a href="https://gist.github.com/BlakeRain/354a21571fa9dfe432b46b833ccec595" class="plain w-full flex flex-col lg:flex-row rounded-md shadow-md dark:shadow-none min-h-[148px] border border-neutral-300 dark:border-neutral-700"><div class="relative lg:order-2 min-w-[33%] min-h-[160px] lg:min-h-fit max-h-[100%]"><img class="absolute top-0 left-0 w-full h-full rounded-r-md object-cover" src="https://github.githubassets.com/images/modules/gists/gist-og-image.png" alt="Allocation of hugepages for DMA in Linux" loading="lazy" decoding="async"></div><div class="font-sans lg:order-1 grow flex flex-col justify-start align-start p-5"><div class="font-semibold">Allocation of hugepages for DMA in Linux</div><div class="grow overflow-y-hidden mt-3 max-h-12">Allocation of hugepages for DMA in Linux. GitHub Gist: instantly share code, notes, and snippets.
</div><div class="flex flex-row flex-wrap align-center gap-1 mt-3.5"><img class="w-[18px] h-[18px] lg:w-[22px] lg:h-[22px] mr-3" alt="GitHub Gist" src="https://github.githubassets.com/favicons/favicon.svg"><span>GitHub Gist</span><span>•</span><span>Blake Rain</span></div></div></a></figure><!--</[]>--><!--<[]>--><blockquote><p>Cover image courtesy of Harrison Broadbent (<a title="" href="https://unsplash.com/@harrisonbroadbent?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit">@harrisonbroadbent</a> on unsplash)</p></blockquote><!--</[]>--></div></article><!--</[]>--><!--<[]>--><button style="transform: translateY(0px)" type="button" tabindex="-1" class="cursor-pointer py-4 px-8 rounded-xl bg-primary opacity-25 hover:opacity-100 text-white fixed bottom-8 right-8 transition-all transition-200 hidden md:block print:hidden">↑ Goto Top</button><!--</[]>--><!--</[]>--><!--</[]>--><!--</[]>--><!--</[]>--></main><!--<[]>--><footer class="print:hidden bg-primary text-neutral-400 text-sm mt-4 min-h-[10rem]"><div class="container mx-auto flex flex-col gap-4 md:gap-0 md:flex-row md:justify-between px-4 sm:px-0 py-6"><div class="flex flex-col gap-4 lg:gap-0"><div>Copyright © 2023 Blake Rain</div><div>Built from <a href="https://git.blakerain.com/BlakeRain/blakerain.com/src/tag/v2.1.1" title="Git repository" target="_blank" rel="noreferrer" class="hover:text-neutral-50">v2.1.1</a> on 2023-10-30</div></div><div class="flex flex-col gap-4 lg:gap-0 lg:items-end"><div class="flex flex-col md:items-end lg:items-start lg:flex-row gap-4 lg:gap-3"><!--<[]>--><a href="/blog" class="hover:text-neutral-50">Latest Posts</a><!--</[]>--><!--<[]>--><a href="/disclaimer" class="hover:text-neutral-50">Disclaimer</a><!--</[]>--><!--<[]>--><a href="/trading/position-size" class="hover:text-neutral-50">Position Size Calculator</a><!--</[]>--></div><div class="flex flex-col md:items-end lg:items-start lg:flex-row gap-4 lg:gap-3"><a href="https://git.blakerain.com/BlakeRain" title="My gitea" target="_blank" rel="noreferrer" class="hover:text-neutral-50">Gitea</a><a href="https://github.com/BlakeRain" title="My GitHub profile" target="_blank" rel="noreferrer" class="hover:text-neutral-50">GitHub Profile</a><a href="https://mastodonapp.uk/@BlakeRain" title="@BlakeRain@mastodonapp.uk" target="_blank" rel="noreferrer" class="hover:text-neutral-50">Mastodon</a><a href="https://status.blakerain.com/" title="Service status" target="_blank" rel="noreferrer" class="hover:text-neutral-50">Status</a></div><!--<[]>--><!--</[]>--></div></div></footer><!--</[]>--></div><!--</[]>--><!--</[]>--><!--</[]>--><!--</[]>--><!--</[]>--><!--</[]>--><!--</[]>--><!--</[]>--></body></html>